// Generated by CoffeeScript 2.7.0
var CHILDREN,
  COMMIT,
  COMPONENT,
  CSS_REGEX,
  DIFF,
  DIFFED,
  DIRTY,
  HOOKS,
  HTML_LOWER_CASE,
  IS_NON_DIMENSIONAL,
  JS_TO_CSS,
  NAMESPACE_REPLACE_REGEX,
  PARENT,
  RENDER,
  SKIP_EFFECTS,
  SVGNS,
  SVG_CAMEL_CASE,
  UNSAFE_NAME,
  VNODE,
  createComponent,
  markAsDirty,
  styleObjToCss,
  indexOf = [].indexOf;
const _preact = require('preact');
const h = _preact.h;
const options = _preact.options;
const Fragment = _preact.Fragment;
SVGNS = 'http://www.w3.org/2000/svg';

//# https://github.com/preactjs/preact-render-to-string/blob/main/src/constants.js
DIFF = '__b';
RENDER = '__r';
DIFFED = 'diffed';
COMMIT = '__c';
SKIP_EFFECTS = '__s';
COMPONENT = '__c';
CHILDREN = '__k';
HOOKS = '__h';
VNODE = '__v';
DIRTY = '__d';
PARENT = '__';

//# Dummy component helpers and other constants from
//# https://github.com/preactjs/preact-render-to-string/blob/main/src/util.js
markAsDirty = function () {
  return this[DIRTY] = true;
};
createComponent = function (vnode, context) {
  return {
    [VNODE]: vnode,
    context: context,
    props: vnode.props,
    // silently drop state updates
    setState: markAsDirty,
    forceUpdate: markAsDirty,
    [DIRTY]: true,
    [HOOKS]: []
  };
};
UNSAFE_NAME = /[\s\n\\\/='"\0<>]/;
NAMESPACE_REPLACE_REGEX = /^(xlink|xmlns|xml)([A-Z])/;
HTML_LOWER_CASE = /^accessK|^auto[A-Z]|^ch|^col|cont|cross|dateT|encT|form[A-Z]|frame|hrefL|inputM|maxL|minL|noV|playsI|readO|rowS|spellC|src[A-Z]|tabI|item[A-Z]/;
SVG_CAMEL_CASE = /^ac|^ali|arabic|basel|cap|clipPath$|clipRule$|color|dominant|enable|fill|flood|font|glyph[^R]|horiz|image|letter|lighting|marker[^WUH]|overline|panose|pointe|paint|rendering|shape|stop|strikethrough|stroke|text[^L]|transform|underline|unicode|units|^v[^i]|^w|^xH/;

//# Convert an Object style to a CSSText string, from
//# https://github.com/preactjs/preact-render-to-string/blob/main/src/util.js
JS_TO_CSS = {};
CSS_REGEX = /([A-Z])/g;
IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;
styleObjToCss = function (s) {
  var name, prop, str, suffix, val;
  str = '';
  for (prop in s) {
    val = s[prop];
    if (val != null && val !== '') {
      name = prop[0] === '-' ? prop : JS_TO_CSS[prop] != null ? JS_TO_CSS[prop] : JS_TO_CSS[prop] = prop.replace(CSS_REGEX, '-$&').toLowerCase();
      suffix = '?';
      if (typeof val === 'number' && !name.startsWith('--') && !IS_NON_DIMENSIONAL.has(prop)) {
        suffix = 'px;';
      }
      str = `${str}${name}:${val}${suffix}`;
    }
  }
  return str || void 0;
};
var RenderToDom = class RenderToDom {
  constructor(options1 = {}) {
    var ref;
    this.options = options1;
    this.document = (ref = this.options.document) != null ? ref : document;
    if (this.options.DOMParser != null) {
      this.DOMParser = new this.options.DOMParser();
    }
    // Global state for the current render pass
    this.beforeDiff = this.afterDiff = this.renderHook = this.unmountHook = null;
  }
  setInnerHTML(node, html, isSvgMode) {
    var child, i, len, parsed, ref, results;
    if (node.innerHTML != null) {
      return node.innerHTML = html;
    } else if (this.DOMParser != null) {
      // Wrap in document element (for multiple tags) and parse
      if (isSvgMode) {
        parsed = this.DOMParser.parseFromString(`<svg xmlns=\"${SVGNS}\">${html}</svg>`, 'image/svg+xml');
      } else {
        parsed = this.DOMParser.parseFromString(`<html>${html}</html>`, 'text/html');
      }
      ref = function () {
        var j, len, ref, results1;
        ref = parsed.documentElement.childNodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          results1.push(child);
        }
        return results1;
      }();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        results.push(node.appendChild(child));
      }
      return results;
    } else {
      throw new Error("RenderToDom: No innerHTML or DOMParser interface; pass DOMParser class via options");
    }
  }
  render(vnode, context = {}) {
    var parent, previousSkipEffects, ref;
    // Don't execute any effects by passing an empty array to `options[COMMIT]`.
    // Further avoid dirty checks and allocations by setting
    // `options[SKIP_EFFECTS]` too.
    previousSkipEffects = options[SKIP_EFFECTS];
    options[SKIP_EFFECTS] = true;
    // store options hooks once before each synchronous render call
    this.beforeDiff = options[DIFF];
    this.afterDiff = options[DIFFED];
    this.renderHook = options[RENDER];
    this.unmountHook = options.unmount;
    parent = h(Fragment, null);
    parent[CHILDREN] = [vnode];
    try {
      return this.recurse(vnode, context, (ref = this.options.svg) != null ? ref : false, void 0, parent);
    } finally {
      if (typeof options[COMMIT] === "function") {
        options[COMMIT](vnode, []);
      }
      options[SKIP_EFFECTS] = previousSkipEffects;
    }
  }

  // Recursively render VNodes to HTML.
  recurse(vnode, context, isSvgMode, selectValue, parent) {
    var cctx, child, childSvgMode, children, component, contextType, count, dom, err, fragment, html, i, len, name, props, provider, rendered, ret, type, val;
    // null, undefined, true, false, '' render as empty fragment
    if (vnode == null || vnode === true || vnode === false || vnode === '') {
      return this.document.createDocumentFragment();
    }
    // Text VNodes get escaped as HTML
    if (typeof vnode !== 'object') {
      if (typeof vnode === 'function') {
        return;
      }
      return this.document.createTextNode(vnode + '');
    }
    // Recurse into children / Arrays and build into a fragment
    if (Array.isArray(vnode)) {
      fragment = this.document.createDocumentFragment();
      for (i = 0, len = vnode.length; i < len; i++) {
        child = vnode[i];
        if (child == null || typeof child === 'boolean') {
          continue;
        }
        fragment.appendChild(this.recurse(child, context, isSvgMode, selectValue, parent));
      }
      return fragment;
    }
    // VNodes have {constructor:undefined} to prevent JSON injection
    if (vnode.constructor !== void 0) {
      return;
    }
    vnode[PARENT] = parent;
    if (typeof this.beforeDiff === "function") {
      this.beforeDiff(vnode);
    }
    ({
      type,
      props
    } = vnode);
    cctx = context;
    // Invoke rendering on Components
    if (typeof type === 'function') {
      if (type === Fragment) {
        // Fragments are the least used components of core that's why
        // branching here for comments has the least effect on perf.
        if (props.UNSTABLE_comment) {
          return this.document.createComment(props.UNSTABLE_comment || '');
        }
        rendered = props.children;
      } else {
        ({
          contextType
        } = type);
        if (contextType != null) {
          provider = context[contextType.__c];
          cctx = provider ? provider.props.value : contextType.__;
        }
        if (type.prototype && typeof type.prototype.render === 'function') {
          rendered = this.renderClassComponent(vnode, context);
          component = vnode[COMPONENT];
        } else {
          component = {
            __v: vnode,
            props: props,
            context: cctx,
            // silently drop state updates
            setState: markAsDirty,
            forceUpdate: markAsDirty,
            __d: true,
            // hooks
            __h: []
          };
          // If a hook invokes setState() to invalidate the component during rendering,
          // re-render it up to 25 times to allow "settling" of memoized states.
          // Note:
          //   This will need to be updated for Preact 11 to use internal.flags rather than component._dirty:
          //   https://github.com/preactjs/preact/blob/d4ca6fdb19bc715e49fd144e69f7296b2f4daa40/src/diff/component.js#L35-L44
          count = 0;
          while (component[DIRTY] && count++ < 25) {
            component[DIRTY] = false;
            if (typeof this.renderHook === "function") {
              this.renderHook(vnode);
            }
            rendered = type.call(component, props, cctx);
          }
          component[DIRTY] = true;
        }
        if (component.getChildContext != null) {
          context = {
            ...context,
            ...component.getChildContext()
          };
        }
        if ((type.getDerivedStateFromError || component.componentDidCatch) && options.errorBoundaries) {
          // When a component returns a Fragment node we flatten it in core, so we
          // need to mirror that logic here too
          if (rendered != null && rendered.type === Fragment && rendered.key == null) {
            rendered = rendered.props.children;
          }
          try {
            return this.recurse(rendered, context, isSvgMode, selectValue, vnode);
          } catch (error) {
            err = error;
            if (type.getDerivedStateFromError) {
              component[NEXT_STATE] = type.getDerivedStateFromError(err);
            }
            if (typeof component.componentDidCatch === "function") {
              component.componentDidCatch(err, {});
            }
            if (component[DIRTY]) {
              rendered = this.renderClassComponent(vnode, context);
              component = vnode[COMPONENT];
              if (component.getChildContext != null) {
                context = {
                  ...context,
                  ...component.getChildContext()
                };
              }
              if (rendered != null && rendered.type === Fragment && rendered.key == null) {
                rendered = rendered.props.children;
              }
              return this.recurse(rendered, context, isSvgMode, selectValue, vnode);
            }
            return this.document.createDocumentFragment();
          } finally {
            if (typeof this.afterDiff === "function") {
              this.afterDiff(vnode);
            }
            vnode[PARENT] = void 0;
            if (typeof this.unmountHook === "function") {
              this.unmountHook(vnode);
            }
          }
        }
      }
      // When a component returns a Fragment node we flatten it in core, so we
      // need to mirror that logic here too
      if (rendered != null && rendered.type === Fragment && rendered.key == null) {
        rendered = rendered.props.children;
      }
      // Recurse into children before invoking the after-diff hook
      dom = this.recurse(rendered, context, isSvgMode, selectValue, parent);
      if (typeof this.afterDiff === "function") {
        this.afterDiff(vnode);
      }
      vnode[PARENT] = void 0;
      if (typeof this.unmountHook === "function") {
        this.unmountHook(vnode);
      }
      return dom;
    }
    // Render Element VNodes to DOM
    if (!this.options.skipNS && this.document.createElementNS != null && isSvgMode || type === 'svg') {
      dom = this.document.createElementNS(SVGNS, type);
    } else {
      dom = this.document.createElement(type);
    }
    children = null;
    for (name in props) {
      val = props[name];
      switch (name) {
        case 'children':
          children = val;
          continue;
        // VDOM-specific props
        case 'key':
        case 'ref':
        case '__self':
        case '__source':
          continue;
        // prefer for/class over htmlFor/className
        case 'htmlFor':
          if (indexOf.call(props, 'for') >= 0) {
            continue;
          }
          name = 'for';
          break;
        case 'className':
          if (indexOf.call(props, 'class') >= 0) {
            continue;
          }
          name = 'class';
          break;
        // Form element reflected properties
        case 'defaultChecked':
          name = 'checked';
          break;
        case 'defaultSelected':
          name = 'selected';
          break;
        // Special value attribute handling
        case 'defaultValue':
        case 'value':
          name = 'value';
          switch (type) {
            // <textarea value="a&b"> --> <textarea>a&amp;b</textarea>
            case 'textarea':
              children = val;
              continue;
            // <select value> is serialized as a selected attribute on the matching option child
            case 'select':
              selectValue = val;
              continue;
            // Add a selected attribute to <option> if its value matches the parent <select> value
            case 'option':
              if (selectValue === val && !('selected' in props)) {
                dom.setAttribute('selected', '');
              }
              continue;
          }
          break;
        case 'dangerouslySetInnerHTML':
          html = val != null ? val.__html : void 0;
          continue;
        // serialize object styles to a CSS string
        case 'style':
          if (typeof v === 'object') {
            val = styleObjToCss(val);
          }
          break;
        case 'acceptCharset':
          name = 'accept-charset';
          break;
        case 'httpEquiv':
          name = 'http-equiv';
          break;
        default:
          if (NAMESPACE_REPLACE_REGEX.test(name)) {
            name = name.replace(NAMESPACE_REPLACE_REGEX, '$1:$2').toLowerCase();
          } else if (UNSAFE_NAME.test(name)) {
            continue;
          } else if ((name[4] === '-' || name === 'draggable') && val != null) {
            // serialize boolean aria-xyz or draggable attribute values as strings
            // `draggable` is an enumerated attribute and not Boolean. A value of `true` or `false` is mandatory
            // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/draggable
            val += '';
          } else if (isSvgMode) {
            if (SVG_CAMEL_CASE.test(name)) {
              if (name === 'panose1') {
                name = 'panose-1';
              } else {
                name = name.replace(/[A-Z]/g, '-$1').toLowerCase();
              }
            }
          } else if (HTML_LOWER_CASE.test(name)) {
            name = name.toLowerCase();
          }
      }
      // write this attribute to the buffer
      if (val != null && val !== false && typeof val !== 'function') {
        if (val === true || val === '') {
          dom.setAttribute(name, '');
        } else {
          dom.setAttribute(name, val + '');
        }
      }
    }
    if (UNSAFE_NAME.test(type)) {
      throw new Error(`${type} is not a valid HTML tag name in ${s}`);
    }
    if (html) {
      // dangerouslySetInnerHTML defined this node's contents
      this.setInnerHTML(dom, html, childSvgMode);
    } else if (typeof children === 'string') {
      // single text child
      dom.appendChild(this.document.createTextNode(children));
    } else if (children != null && children !== false && children !== true) {
      // recurse into this element VNode's children
      childSvgMode = type === 'svg' || type !== 'foreignObject' && isSvgMode;
      ret = this.recurse(children, context, childSvgMode, selectValue, parent);
      dom.appendChild(ret);
    }
    if (typeof this.afterDiff === "function") {
      this.afterDiff(vnode);
    }
    vnode[PARENT] = void 0;
    if (typeof this.unmountHook === "function") {
      this.unmountHook(vnode);
    }
    return dom;
  }
  renderClassComponent(vnode, context) {
    var c, isMounting, type;
    type = vnode.type;
    isMounting = true;
    if (vnode[COMPONENT]) {
      isMounting = false;
      c = vnode[COMPONENT];
      c.state = c[NEXT_STATE];
    } else {
      c = new type(vnode.props, context);
    }
    vnode[COMPONENT] = c;
    c[VNODE] = vnode;
    c.props = vnode.props;
    c.context = context;
    c[DIRTY] = true; // turn off stateful re-rendering
    if (c.state == null) {
      c.state = {};
    }
    if (c[NEXT_STATE] == null) {
      c[NEXT_STATE] = c.state;
    }
    if (type.getDerivedStateFromProps != null) {
      c.state = {
        ...c.state,
        ...type.getDerivedStateFromProps(c.props, c.state)
      };
    } else if (isMounting && c.componentWillMount) {
      c.componentWillMount();
      // If the user called setState in cWM we need to flush pending,
      // state updates. This is the same behavior in React.
      if (c[NEXT_STATE] !== c.state) {
        c.state = c[NEXT_STATE];
      }
    } else if (!isMounting && c.componentWillUpdate) {
      c.componentWillUpdate();
    }
    if (typeof this.renderHook === "function") {
      this.renderHook(vnode);
    }
    return c.render(c.props, c.state, c.context);
  }
};
exports.RenderToDom = RenderToDom;
var RenderToXMLDom = class RenderToXMLDom extends RenderToDom {
  constructor(options) {
    var xmldom;
    xmldom = options.xmldom;
    super({
      ...options,
      document: new xmldom.DOMImplementation().createDocument(),
      DOMParser: xmldom.DOMParser
    });
  }
};
exports.RenderToXMLDom = RenderToXMLDom;
var RenderToJSDom = class RenderToJSDom extends RenderToDom {
  constructor(options) {
    var jsdom;
    jsdom = options.jsdom;
    if (jsdom.JSDOM != null) {
      jsdom = jsdom.JSDOM;
    }
    super({
      ...options,
      document: new jsdom('<!DOCTYPE html>').window.document
    });
  }
};
exports.RenderToJSDom = RenderToJSDom;