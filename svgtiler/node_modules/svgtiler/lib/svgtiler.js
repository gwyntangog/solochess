// Generated by CoffeeScript 2.7.0
(function() {

  /*
  ids generated at the top level have the temporary form "_globalN_ID",
  where "N" is a globally unique integer and "ID" is the (escaped) desired id
  (to be assigned a version number later).
  */
  /*
  Babel plugin to add implicit `export default` to last line of program,
  to simulate the effect of `eval` but in a module context.
  Only added if there isn't already an `export default` or `exports.default`
  in the code, and when the last line is an object, array, or function
  expression (with the idea that it wouldn't do much by itself).
  */
  var $static, ASCIIDrawing, ASCIIMapping, Args, ArrayWrapper, AutoDrawing, CSSStyle, CSVDrawing, CoffeeMapping, CoffeeScript, Context, DOMParser, DSVDrawing, Drawing, Drawings, Driver, DummyInput, HasSettings, Input, JSMapping, Mapping, Mappings, PSVDrawing, ParsedArgs, Render, SSVDrawing, SVGContent, SVGFile, SVGNS, SVGSymbol, SVGTilerError, SVGWrapped, ShareSetter, Style, Styles, StylusStyle, TSVDrawing, Tile, XLINKNS, XLSXDrawings, XMLSerializer, allBlank, attributeOrStyle, babelConfig, blankCells, cloneSettings, contentType, convert, currentContext, currentDriver, currentInits, currentRender, dashArgRegExp, defaultSettings, deleteFile, domImplementation, domRecurse, emptyContainers, errorSymbol, escapeId, extensionMap, extensionOf, extractBoundingBox, extractZIndex, filter, findRefs, fs, getContext, getContextString, getDriver, getHref, getOutputDir, getRender, getSetting, getSettings, glob, globalAdd, globalBackground, globalDef, globalDefs, globalId, globalIdCount, globalShare, graphemeSplitter, help, hrefAttr, implicitFinalExportDefault, infinityRegExp, inputCache, inputRequire, isAuto, isGlob, isPreact, loadSVG, main, match, maybeWrite, metadata, multiCall, needVersion, parseBox, parseDim, parseIntoArgs, parseNum, parseNumOrInfinity, path, paths, pirates, preactRenderToDom, prefixCount, prefixForFile, prefixForFilename, prefixSVGIds, prettyXML, processor, refRegExp, removeAttributeOrStyle, removeSVGComments, renderDOM, resolve, run, runWithContext, runWithDriver, runWithRender, skipDef, splitIntoLines, svgBBox, svgtiler, svgtilerRequire, unglobalId, units, unrecognizedSymbol, verboseBabel, whitespace, wrapStatic, xmldom, zeroSizeReplacement,
    indexOf = [].indexOf,
    splice = [].splice;

  if (typeof window === "undefined" || window === null) {
    path = require('path');
    fs = require('fs');
    xmldom = require('@xmldom/xmldom');
    DOMParser = xmldom.DOMParser;
    domImplementation = new xmldom.DOMImplementation();
    XMLSerializer = xmldom.XMLSerializer;
    prettyXML = require('prettify-xml');
    graphemeSplitter = new require('grapheme-splitter')();
    metadata = require('../package.json');
    try {
      metadata.modified = (fs.statSync(__filename)).mtimeMs;
    } catch (error1) {}
  } else {
    DOMParser = window.DOMParser; // escape CoffeeScript scope
    domImplementation = document.implementation;
    XMLSerializer = window.XMLSerializer; // escape CoffeeScript scope
    path = {
      basename: function(x) {
        return /[^\/]*$/.exec(x)[0];
      },
      extname: function(x) {
        return /\.[^\/]+$/.exec(x)[0];
      },
      dirname: function(x) {
        return /[^]*\/|/.exec(x)[0];
      }
    };
    graphemeSplitter = {
      splitGraphemes: function(x) {
        return x.split('');
      }
    };
    metadata = {
      version: '(web)'
    };
  }

  //# Combine a directory and filename, handling more cases than path module.
  //# Like path.join, keep using relative filenames if both are relative.
  //# Like path.resolve, correctly handle absolute filenames (ignore dirname).
  //# Also allow for null dirname (ignored) or null filename (returned).
  resolve = (dirname, filename) => {
    if ((dirname == null) || (filename == null) || path.isAbsolute(filename)) {
      return filename;
    } else {
      return path.join(dirname, filename);
    }
  };

  //# Register `require` hooks of Babel and CoffeeScript,
  //# so that imported/required modules are similarly processed.
  if (typeof window === "undefined" || window === null) {
    implicitFinalExportDefault = function({types}) {
      return {
        visitor: {
          Program: function(path) {
            var body, exportLast, exportedDefault, last, lastNode;
            body = path.get('body');
            if (!body.length) { // empty program
              return;
            }
            //# Check for existing `export default` or `exports.default` or
            //# `exports['default']`, in which case definitely don't add one.
            exportedDefault = false;
            path.traverse({
              ExportDefaultDeclaration: function(path) {
                exportedDefault = true;
              },
              MemberExpression: function(path) {
                var check, node;
                ({node} = path);
                check = function(key, value) {
                  return types.isIdentifier(node.object) && node.object.name === key && ((types.isIdentifier(node.property) && node.property.name === value) || (types.isStringLiteral(node.property) && node.property.value === value));
                };
                exportedDefault || (exportedDefault = check('exports', 'default') || check('module', 'exports'));
              }
            });
            if (exportedDefault) {
              return;
            }
            last = body[body.length - 1];
            lastNode = last.node;
            if (types.isExpressionStatement(last) && (types.isObjectExpression(lastNode.expression) || types.isFunctionExpression(lastNode.expression) || types.isArrowFunctionExpression(lastNode.expression) || types.isArrayExpression(lastNode.expression))) {
              // not AssignmentExpression or CallExpression
              exportLast = types.exportDefaultDeclaration(lastNode.expression);
              exportLast.leadingComments = lastNode.leadingComments;
              exportLast.innerComments = lastNode.innerComments;
              exportLast.trailingComments = lastNode.trailingComments;
              last.replaceWith(exportLast);
            }
          }
        }
      };
    };
    //# Modify `svgtiler.require` calls to add __dirname as third argument,
    //# so that files can be located relative to the module's directory.
    svgtilerRequire = function({types}) {
      return {
        visitor: {
          CallExpression: function(path) {
            var callee, node;
            ({node} = path);
            ({callee} = node);
            if (!types.isMemberExpression(callee)) {
              return;
            }
            if (!(types.isIdentifier(callee.object) && callee.object.name === 'svgtiler')) {
              return;
            }
            if (!(types.isIdentifier(callee.property) && callee.property.name === 'require')) {
              return;
            }
            while (node.arguments.length < 2) {
              node.arguments.push(types.identifier('undefined'));
            }
            if (node.arguments.length === 2) {
              node.arguments.push(types.identifier('__dirname'));
            }
          }
        }
      };
    };
    verboseBabel = function({types}) {
      return {
        post: function(state) {
          var filename, ref, ref1, ref2, ref3, ref4;
          if (!((ref = getSettings()) != null ? ref.verbose : void 0)) {
            return;
          }
          if (((ref1 = state.opts) != null ? ref1.filename : void 0) != null) {
            filename = `[${state.opts.filename}]`;
          } else if ((ref2 = state.inputMap) != null ? (ref3 = ref2.sourcemap) != null ? (ref4 = ref3.sources) != null ? ref4.length : void 0 : void 0 : void 0) {
            filename = `[converted from ${state.inputMap.sourcemap.sources.join(' & ')}]`;
          } else {
            filename = '';
          }
          console.log('# Babel conversion input:', filename);
          console.log(state.code);
          console.log('# Babel conversion output:', filename);
          console.log(require('@babel/generator').default(state.ast, babelConfig).code);
          console.log('# End of Babel conversion', filename);
        }
      };
    };
    babelConfig = {
      plugins: [
        implicitFinalExportDefault,
        svgtilerRequire,
        [
          require.resolve('babel-plugin-auto-import'),
          {
            declarations: [
              {
                default: 'preact',
                path: 'preact'
              },
              {
                default: 'svgtiler',
                members: ['share'],
                path: 'svgtiler'
              }
            ]
          }
        ],
        require.resolve('@babel/plugin-transform-modules-commonjs'),
        [
          require.resolve('@babel/plugin-transform-react-jsx'),
          {
            useBuiltIns: true,
            runtime: 'automatic',
            importSource: 'preact',
            //pragma: 'preact.h'
            //pragmaFrag: 'preact.Fragment'
            throwIfNamespace: false
          }
        ],
        require.resolve('babel-plugin-module-deps'),
        verboseBabel
      ],
      //inputSourceMap: true  # CoffeeScript sets this to its own source map
      sourceMaps: 'inline',
      retainLines: true
    };
    //# Tell CoffeeScript's register to transpile with our Babel config.
    module.options = {
      bare: true, // needed for implicitFinalExportDefault
      //inlineMap: true  # rely on Babel's source map
      transpile: babelConfig
    };
    //# Prevent Babel from caching its results, for changes to our plugins.
    require('@babel/register')({
      ...babelConfig,
      cache: false
    });
    CoffeeScript = require('coffeescript');
    CoffeeScript.FILE_EXTENSIONS = ['.coffee', '.cjsx'];
    CoffeeScript.register();
  }

  defaultSettings = {
    //# Log otherwise invisible actions to aid with debugging.
    //# Currently, 0 = none, nonzero = all, but there may be levels in future.
    verbose: 0,
    //# Force all tiles to have specified width or height.
    forceWidth: null, //# default: no size forcing
    forceHeight: null, //# default: no size forcing
    //# Inline <image>s into output SVG (replacing URLs to other files).
    inlineImages: typeof window === "undefined" || window === null,
    //# Process hidden sheets within spreadsheet files.
    keepHidden: false,
    //# Don't delete blank extreme rows/columns.
    keepMargins: false,
    //# Don't make all rows have the same number of columns by padding with
    //# empty strings.
    keepUneven: false,
    //# Array of conversion formats such as 'pdf' or 'pdf'.
    formats: null,
    //# Override for output file's stem (basename without extension).
    //# Can use `*` to refer to input file's stem, to add prefix or suffix.
    outputStem: null,
    //# Directories to output all or some files.
    //# Can also include stem overrides like "prefix_*_suffix".
    outputDir: null, //# default: same directory as input
    outputDirExt: { //# by extension; default is to use outputDir
      '.svg': null,
      '.pdf': null,
      '.png': null,
      '.svg_tex': null
    },
    //# Delete output files instead of creating them, like `make clean`.
    clean: false,
    //# Path to inkscape.  Default searches PATH.
    inkscape: 'inkscape',
    //# Default overflow behavior is 'visible' unless --no-overflow specified;
    //# use `overflow:hidden` to restore normal SVG behavior of keeping each tile
    //# within its bounding box.
    overflowDefault: 'visible',
    //# When a mapping refers to an SVG filename, assume this encoding.
    svgEncoding: 'utf8',
    //# Move <text> from SVG to accompanying LaTeX file.tex.
    texText: false,
    //# Use `href` instead of `xlink:href` attribute in <use> and <image>.
    //# `href` behaves better in web browsers, but `xlink:href` is more
    //# compatible with older SVG drawing programs.
    useHref: typeof window !== "undefined" && window !== null,
    //# Wrap <symbol> tags inside <defs>. Workaround for a bug in Inkscape,
    //# which duplicates <symbol>s inside of <symbol>s unless the inner symbols
    //# are wrapped in <def>s. So use this when nesting, until bug is fixed.
    //# https://gitlab.com/inkscape/inbox/-/issues/12642
    useDefs: false,
    //# Add `data-key`/`data-i`/`data-j`/`data-k` attributes to <use> elements,
    //# which specify the drawing key and location (row i, column j, layer k).
    useData: typeof window !== "undefined" && window !== null,
    //# Background rectangle fill color.
    background: null,
    //# Glob pattern for Maketiles.
    maketile: '[mM]aketile.{args,coffee,js}',
    //# renderDOM-specific
    filename: 'drawing.asc', // default filename when not otherwise specified
    keepParent: false,
    keepClass: false,
    //# Major state
    mappings: null, // should be valid argument to new Mappings
    styles: null // should be valid argument to new Styles
  };

  cloneSettings = function(settings, addArrays) {
    settings = {...settings};
    if (settings.formats != null) {
      settings.formats = [...settings.formats];
    } else if (addArrays) {
      settings.formats = [];
    }
    if (settings.mappings != null) {
      settings.mappings = new Mappings(settings.mappings);
    } else if (addArrays) {
      settings.mappings = new Mappings();
    }
    if (settings.styles != null) {
      settings.styles = new Styles(settings.styles);
    } else if (addArrays) {
      settings.styles = new Styles();
    }
    return settings;
  };

  getSetting = function(settings, key) {
    var ref;
    return (ref = settings != null ? settings[key] : void 0) != null ? ref : defaultSettings[key];
  };

  getOutputDir = function(settings, extension) {
    var dir, err, ref, ref1;
    dir = (ref = (ref1 = getSetting(settings, 'outputDirExt')) != null ? ref1[extension] : void 0) != null ? ref : getSetting(settings, 'outputDir');
    if (dir) {
      try {
        fs.mkdirSync(dir, {
          recursive: true
        });
      } catch (error1) {
        err = error1;
        console.warn(`Failed to make directory '${dir}': ${err}`);
      }
    }
    return dir;
  };

  HasSettings = class HasSettings {
    getSetting(key) {
      return getSetting(this.settings, key);
    }

    getOutputDir(extension) {
      return getOutputDir(this.settings, extension);
    }

  };

  globalShare = {}; // for shared data between mapping modules

  SVGNS = 'http://www.w3.org/2000/svg';

  XLINKNS = 'http://www.w3.org/1999/xlink';

  splitIntoLines = function(data) {
    return data.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n$/, '').split('\n'); // Windows EOL -> \n // Mac EOL -> \n // ignore newline on last line
  };

  whitespace = /[\s\uFEFF\xA0]+/; //# based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim

  extensionOf = function(filename) {
    return path.extname(filename).toLowerCase();
  };

  SVGTilerError = class SVGTilerError extends Error {
    constructor(message) {
      super(message);
      this.name = 'SVGTilerError';
    }

  };

  parseNum = function(x) {
    var parsed;
    parsed = parseFloat(x);
    if (isNaN(parsed)) {
      return null;
    } else {
      return parsed;
    }
  };

  //# Allow Infinity, \infty, Inf with optional sign prefix
  infinityRegExp = /^\s*([+-]?)\\?infi?n?i?t?y?\s*$/i;

  parseNumOrInfinity = function(x) {
    var match;
    if ((match = infinityRegExp.exec(x)) != null) {
      if (match[1] === '-') {
        return -2e308;
      } else {
        return 2e308;
      }
    } else {
      return parseNum(x);
    }
  };

  //# Conversion from arbitrary unit to px (SVG units),
  //# from https://www.w3.org/TR/css-values-3/#absolute-lengths
  units = {
    cm: 96 / 2.54,
    mm: 96 / 25.4,
    Q: 96 / 25.4 / 4,
    in: 96,
    pc: 96 / 6,
    pt: 96 / 72,
    px: 1,
    undefined: 1
  };

  parseDim = function(x) {
    var match;
    match = /^\s*([0-9.]+)\s*([a-zA-Z]\w+)?\s*$/.exec(x);
    if (match == null) {
      return null;
    }
    if (units.hasOwnProperty(match[2])) {
      return parseNum(match[1]) * units[match[2]];
    } else {
      console.warn(`Unrecognized unit ${match[2]}`);
      return parseNum(match[1]);
    }
  };

  parseBox = function(box, allowNull) {
    if (!box) {
      return null;
    }
    box = box.split(/\s*[\s,]\s*/).map(parseNum);
    if (!allowNull) {
      if (indexOf.call(box, null) >= 0) {
        return null;
      }
    }
    return box;
  };

  extractBoundingBox = function(xml) {
    /*
    Parse and return root `boundingBox` attribute,
    possibly under the old name of `overflowBox`.
    Also remove them if present, so output is valid SVG.
    */
    var box;
    box = xml.getAttribute('boundingBox') || xml.getAttribute('overflowBox');
    xml.removeAttribute('boundingBox');
    xml.removeAttribute('overflowBox');
    if ((box != null ? box.toLowerCase().trim() : void 0) === 'none') {
      return [null, null, null, null];
    } else {
      return parseBox(box, true);
    }
  };

  svgBBox = function(dom) {
    var recurse, viewBox;
    //# xxx Many unsupported features!
    //#   - transformations
    //#   - used symbols/defs
    //#   - paths
    //#   - text
    //#   - line widths which extend bounding box
    recurse = function(node) {
      var child, coord, cx, cy, point, points, r, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rx, ry, viewBox, viewBoxes, x1, x2, xMax, xMin, xs, y1, y2, yMax, yMin, ys;
      if (node.nodeType !== node.ELEMENT_NODE || ((ref = node.nodeName) === 'defs' || ref === 'use')) {
        return null;
      }
      // Ignore <symbol>s except the root <symbol> that we're bounding
      if (node.nodeName === 'symbol' && node !== dom) {
        return null;
      }
      switch (node.tagName) {
        case 'rect':
        case 'image':
          //# For <image>, should autodetect image size (#42)
          return [(ref1 = parseNum(node.getAttribute('x'))) != null ? ref1 : 0, (ref2 = parseNum(node.getAttribute('y'))) != null ? ref2 : 0, (ref3 = parseNum(node.getAttribute('width'))) != null ? ref3 : 0, (ref4 = parseNum(node.getAttribute('height'))) != null ? ref4 : 0];
        case 'circle':
          cx = (ref5 = parseNum(node.getAttribute('cx'))) != null ? ref5 : 0;
          cy = (ref6 = parseNum(node.getAttribute('cy'))) != null ? ref6 : 0;
          r = (ref7 = parseNum(node.getAttribute('r'))) != null ? ref7 : 0;
          return [cx - r, cy - r, 2 * r, 2 * r];
        case 'ellipse':
          cx = (ref8 = parseNum(node.getAttribute('cx'))) != null ? ref8 : 0;
          cy = (ref9 = parseNum(node.getAttribute('cy'))) != null ? ref9 : 0;
          rx = (ref10 = parseNum(node.getAttribute('rx'))) != null ? ref10 : 0;
          ry = (ref11 = parseNum(node.getAttribute('ry'))) != null ? ref11 : 0;
          return [cx - rx, cy - ry, 2 * rx, 2 * ry];
        case 'line':
          x1 = (ref12 = parseNum(node.getAttribute('x1'))) != null ? ref12 : 0;
          y1 = (ref13 = parseNum(node.getAttribute('y1'))) != null ? ref13 : 0;
          x2 = (ref14 = parseNum(node.getAttribute('x2'))) != null ? ref14 : 0;
          y2 = (ref15 = parseNum(node.getAttribute('y2'))) != null ? ref15 : 0;
          xMin = Math.min(x1, x2);
          yMin = Math.min(y1, y2);
          return [xMin, yMin, Math.max(x1, x2) - xMin, Math.max(y1, y2) - yMin];
        case 'polyline':
        case 'polygon':
          points = (function() {
            var l, len, ref16, results;
            ref16 = node.getAttribute('points').trim().split(/\s+/);
            results = [];
            for (l = 0, len = ref16.length; l < len; l++) {
              point = ref16[l];
              results.push((function() {
                var len1, n, ref17, results1;
                ref17 = point.split(/,/);
                results1 = [];
                for (n = 0, len1 = ref17.length; n < len1; n++) {
                  coord = ref17[n];
                  results1.push(parseFloat(coord));
                }
                return results1;
              })());
            }
            return results;
          })();
          xs = (function() {
            var l, len, results;
            results = [];
            for (l = 0, len = points.length; l < len; l++) {
              point = points[l];
              results.push(point[0]);
            }
            return results;
          })();
          ys = (function() {
            var l, len, results;
            results = [];
            for (l = 0, len = points.length; l < len; l++) {
              point = points[l];
              results.push(point[1]);
            }
            return results;
          })();
          xMin = Math.min(...xs);
          yMin = Math.min(...ys);
          if (isNaN(xMin) || isNaN(yMin)) { // invalid points attribute; don't render
            return null;
          } else {
            return [xMin, yMin, Math.max(...xs) - xMin, Math.max(...ys) - yMin];
          }
          break;
        default:
          viewBoxes = (function() {
            var l, len, ref16, results;
            ref16 = node.childNodes;
            results = [];
            for (l = 0, len = ref16.length; l < len; l++) {
              child = ref16[l];
              results.push(recurse(child));
            }
            return results;
          })();
          viewBoxes = (function() {
            var l, len, results;
            results = [];
            for (l = 0, len = viewBoxes.length; l < len; l++) {
              viewBox = viewBoxes[l];
              if (viewBox != null) {
                results.push(viewBox);
              }
            }
            return results;
          })();
          xMin = Math.min(...((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = viewBoxes.length; l < len; l++) {
              viewBox = viewBoxes[l];
              results.push(viewBox[0]);
            }
            return results;
          })()));
          yMin = Math.min(...((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = viewBoxes.length; l < len; l++) {
              viewBox = viewBoxes[l];
              results.push(viewBox[1]);
            }
            return results;
          })()));
          xMax = Math.max(...((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = viewBoxes.length; l < len; l++) {
              viewBox = viewBoxes[l];
              results.push(viewBox[0] + viewBox[2]);
            }
            return results;
          })()));
          yMax = Math.max(...((function() {
            var l, len, results;
            results = [];
            for (l = 0, len = viewBoxes.length; l < len; l++) {
              viewBox = viewBoxes[l];
              results.push(viewBox[1] + viewBox[3]);
            }
            return results;
          })()));
          return [xMin, yMin, xMax - xMin, yMax - yMin];
      }
    };
    viewBox = recurse(dom);
    if ((viewBox == null) || indexOf.call(viewBox, 2e308) >= 0 || indexOf.call(viewBox, -2e308) >= 0) {
      return null;
    } else {
      return viewBox;
    }
  };

  isAuto = function(value) {
    return typeof value === 'string' && /^\s*auto\s*$/i.test(value);
  };

  attributeOrStyle = function(node, attr, styleKey = attr) {
    var match, style, value;
    if (value = node.getAttribute(attr)) {
      return value.trim();
    } else {
      style = node.getAttribute('style');
      if (style) {
        match = RegExp(`(?:^|;)\\s*${styleKey}\\s*:\\s*([^;\\s][^;]*)`, "i").exec(style);
        return match != null ? match[1] : void 0;
      }
    }
  };

  removeAttributeOrStyle = function(node, attr, styleKey = attr) {
    var newStyle, style;
    node.removeAttribute(attr);
    style = node.getAttribute('style');
    if (style == null) {
      return;
    }
    newStyle = style.replace(RegExp(`(?:^|;)\\s*${styleKey}\\s*:\\s*([^;\\s][^;]*)`, "i"), '');
    if (style !== newStyle) {
      if (newStyle.trim()) {
        return node.setAttribute('style', newStyle);
      } else {
        return node.removeAttribute('style');
      }
    }
  };

  getHref = function(node) {
    var href, key, l, len, ref;
    ref = ['xlink:href', 'href'];
    for (l = 0, len = ref.length; l < len; l++) {
      key = ref[l];
      if (href = node.getAttribute(key)) {
        return {
          key: key,
          href: href
        };
      }
    }
    return {
      key: null,
      href: null
    };
  };

  extractZIndex = function(node) {
    var z;
    //# Check whether DOM node has a specified z-index, defaulting to zero.
    //# Special values of Infinity or -Infinity are allowed.
    //# Also remove z-index attribute, so output is valid SVG.
    //# Note that z-index must be an integer.
    //# 1. https://www.w3.org/Graphics/SVG/WG/wiki/Proposals/z-index suggests
    //# a z-index="..." attribute.  Check for this first.
    //# 2. Look for style="z-index:..." as in HTML.
    z = parseNumOrInfinity(attributeOrStyle(node, 'z-index'));
    removeAttributeOrStyle(node, 'z-index');
    return z != null ? z : 0;
  };

  domRecurse = function(node, callback) {
    var child, nextChild;
    /*
    Recurse through DOM starting at `node`, calling `callback(node)`
    on every recursive node, including `node` itself.
    `callback()` should return a true value if you want to recurse into
    the specified node's children (typically, when there isn't a match).
    Robust against node being replaced.
    */
    if (!callback(node)) {
      return;
    }
    if (!node.hasChildNodes()) {
      return;
    }
    child = node.lastChild;
    while (child != null) {
      nextChild = child.previousSibling;
      domRecurse(child, callback);
      child = nextChild;
    }
  };

  refRegExp = /\burl\s*\(\s*\#([^()]*)\)|\b(?:url|src)\s*\(\s*(['"])\s*\#(.*?)\2\s*\)/g; // url() without quotes
  // url() with quotes, or src() which requires quotes

  findRefs = (root) => {
    var refs;
    //# Returns an array of id-based references to other elements in the SVG.
    refs = [];
    domRecurse(root, (node) => {
      var attr, l, len, match, ref, ref1, value;
      if (node.attributes == null) {
        return;
      }
      ref = node.attributes;
      for (l = 0, len = ref.length; l < len; l++) {
        attr = ref[l];
        if (((ref1 = attr.name) === 'href' || ref1 === 'xlink:href') && (value = attr.value.trim()).startsWith('#')) {
          refs.push({
            id: value.slice(1).trim(),
            node,
            attr: attr.name
          });
        } else {
          while ((match = refRegExp.exec(attr.value)) != null) {
            refs.push({
              id: (match[1] || match[3]).trim(),
              node,
              attr: attr.name
            });
          }
        }
      }
      return true;
    });
    return refs;
  };

  contentType = {
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml'
  };

  //# Support for `require`/`import`ing images.
  //# SVG files get parsed into Preact Virtual DOM so you can manipulate them,
  //# while raster images get converted into <image> Preact Virtual DOM elements.
  //# In either case, DOM gets `svg` attribute with raw SVG string.
  if (typeof window === "undefined" || window === null) {
    pirates = require('pirates');
    pirates.settings = defaultSettings;
    pirates.addHook(function(code, filename) {
      var domCode, href, raw;
      if ('.svg' === extensionOf(filename)) {
        raw = code;
        code = removeSVGComments(code);
        code = prefixSVGIds(code, prefixForFilename(filename));
        domCode = require('@babel/core').transform(`module.exports = ${code}`, {...babelConfig, filename});
        return `${domCode.code}
module.exports.svg = ${JSON.stringify(code)};
module.exports.raw = ${JSON.stringify(raw)};`;
      } else {
        href = hrefAttr(pirates.settings);
        return `module.exports = require('preact').h('image', ${JSON.stringify({
          [`${href}`]: filename
        })});
module.exports.svg = '<image ${href}="'+${JSON.stringify(filename.replace(/"/g, '&quot;'))}+'"/>';`;
      }
    }, {
      exts: Object.keys(contentType)
    });
  }

  isPreact = function(data) {
    return typeof data === 'object' && ((data != null ? data.type : void 0) != null) && (data.props != null);
  };

  $static = Symbol('svgtiler.static');

  wrapStatic = function(x) {
    return {
      [$static]: x // exported as `static` but that's reserved
    };
  };

  
  //fileCache = new Map
  loadSVG = function(filename, settings) {
    //if (found = fileCache.get filename)?
    //  return found
    //data =
    return fs.readFileSync(filename, {
      encoding: getSetting(settings, 'svgEncoding')
    });
  };

  //# TODO: Handle <?xml encoding="..."?> or BOM to override svgEncoding.
  //fileCache.set filename, data
  //data
  escapeId = function(key) {
    /*
    According to XML spec [https://www.w3.org/TR/xml/#id],
    id/href follows the XML name spec: [https://www.w3.org/TR/xml/#NT-Name]
      NameStartChar ::= ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
      NameChar      ::= NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
      Name          ::= NameStartChar (NameChar)*
    In addition, colons in IDs fail when embedding an SVG via <img>.
    We use encodeURIComponent which escapes everything except
      A-Z a-z 0-9 - _ . ! ~ * ' ( )
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent]
    into %-encoded symbols, plus we encode _ . ! ~ * ' ( ) and - 0-9 (start only).
    But % (and %-encoded) symbols are not supported, so we replace '%' with '_',
    an allowed character that we escape.
    In the special case of a blank key, we use the special _blank which cannot
    be generated by the escaping process.
    */
    return (encodeURIComponent(key).replace(/[_\.!~*'()]|^[\-0-9]/g, function(c) {
      return `%${c.charCodeAt(0).toString(16).toUpperCase()}`;
    }).replace(/%/g, '_')) || '_blank';
  };

  zeroSizeReplacement = 1;

  removeSVGComments = function(svg) {
    //# Remove SVG/XML comments such as <?xml...?> and <!DOCTYPE>
    //# (spec: https://www.w3.org/TR/2008/REC-xml-20081126/#NT-prolog)
    return svg.replace(/<\?[^]*?\?>|<![^-][^]*?>|<!--[^]*?-->/g, '');
  };

  prefixSVGIds = function(svg, prefix) {
    var idMap;
    //# Prefix all id, href, xlink:href for scoping external SVG
    idMap = new Map();
    svg = svg.replace(/(?<![\w:-])((?:xml:)?id\s*=\s*)(["'])(.*?)(\2)/g, (attr, pre, quote, id, post) => {
      if (idMap.has(id)) {
        console.warn(`SVG ${prefix} has duplicate id: ${id}`);
      } else {
        idMap.set(id, `${prefix}_${id}`);
      }
      return `${pre}${quote}${idMap.get(id)}${quote}`;
    });
    if (idMap.size) { // some ids to remap
      svg = svg.replace(/(?<![\w:-])((?:xlink:)?href\s*=\s*)(["'])(.*?)(\2)/g, (attr, pre, quote, href, post) => {
        var match, newId, oldId;
        href = href.trim();
        if (href.startsWith('#')) {
          if ((newId = idMap.get(href.slice(1))) != null) {
            href = `#${newId}`;
          } else {
            console.warn(`SVG ${prefix} has reference to unknown id: ${id}`);
          }
        } else {
          while ((match = refRegExp.exec(attr.value)) != null) {
            oldId = match[1] || match[3];
            if ((newId = idMap.get(oldId)) != null) {
              href = href.replace(`#${oldId}`, `#${newId}`);
            } else {
              console.warn(`SVG ${prefix} has reference to unknown id: ${oldId}`);
            }
          }
        }
        return `${pre}${quote}${href}${quote}`;
      });
    }
    return svg;
  };

  //# Construct unique prefix for IDs from a given filename
  prefixForFile = new Map();

  prefixCount = new Map();

  prefixForFilename = function(filename) {
    var count, prefix;
    if (prefixForFile.has(filename)) {
      return prefixForFile.get(filename);
    }
    prefix = path.basename(filename);
    // Strip characters that need escaping (see escapeId)
    prefix = prefix.slice(0, -path.extname(prefix).length).replace(/^[^a-zA-Z]+|[^\w.-]/g, '');
    if (prefixCount.has(prefix)) {
      while (prefixCount.has(prefix)) {
        count = prefixCount.get(prefix);
        prefixCount.set(prefix, count + 1);
        prefix = `${prefix}${count}`;
      }
    } else {
      prefixCount.set(prefix, 0);
    }
    prefixForFile.set(filename, prefix);
    return prefix;
  };

  //currentMapping = null
  currentRender = null;

  currentDriver = null;

  currentContext = null;

  //getMapping = ->
  //  ## Returns current `Mapping` object,
  //  ## when used at top level of a JS/CS mapping file.
  //  currentMapping
  //runWithMapping = (mapping, fn) ->
  //  ## Runs the specified function `fn` as if it were called
  //  ## at the top level of the specified mapping.
  //  oldMapping = currentMapping
  //  currentMapping = mapping
  //  try
  //    fn()
  //  finally
  //    currentMapping = oldMapping
  getRender = function() {
    //# Returns current `Render` object, when used within its execution.
    return currentRender;
  };

  runWithRender = function(render, fn) {
    var oldRender;
    //# Runs the specified function `fn` as if it were called
    //# from the specified `render`.
    oldRender = currentRender;
    currentRender = render;
    try {
      return fn();
    } finally {
      currentRender = oldRender;
    }
  };

  getDriver = function() {
    //# Returns current `Driver` object, when used within its execution.
    return currentDriver;
  };

  runWithDriver = function(driver, fn) {
    var oldDriver;
    //# Runs the specified function `fn` as if it were called
    //# from the specified `driver`.
    oldDriver = currentDriver;
    currentDriver = driver;
    try {
      return fn();
    } finally {
      currentDriver = oldDriver;
    }
  };

  getContext = function() {
    //# Returns current `Context` object, when used within a mapping function.
    return currentContext;
  };

  runWithContext = function(context, fn) {
    var oldContext;
    //# Runs the specified function `fn` as if it were called
    //# within the specified `context`.
    oldContext = currentContext;
    currentContext = context;
    try {
      return fn();
    } finally {
      currentContext = oldContext;
    }
  };

  getContextString = function() {
    //# Returns string describing the current context
    if (currentContext != null) {
      return `tile '${currentContext.tile}' in row ${currentContext.i + 1}, column ${currentContext.j + 1} of drawing '${currentContext.drawing.filename}'`;
    //else if currentMapping?
    //  "mapping '#{currentMapping.filename}'"
    } else if (currentRender != null) {
      return `render of '${currentRender.drawing.filename}'`;
    } else {
      return 'unknown context';
    }
  };

  getSettings = function() {
    /*
    Returns currently active `Settings` object, if any, from
    * the current Render process (which includes the case of an active Context),
    * the current Mapping file,
    * the current Driver process, or
    * `defaultSettings` if none of the above are currently active.
     */
    //if currentContext?
    //  currentContext.render.settings
    if (currentRender != null) {
      return currentRender.settings;
    //else if currentMapping?
    //  currentMapping.settings
    } else if (currentDriver != null) {
      return currentDriver.settings;
    } else {
      return defaultSettings;
    }
  };

  //# SVG container element tags from
  //# https://developer.mozilla.org/en-US/docs/Web/SVG/Element#container_elements
  //# that are useless when empty and have no `id` attribute.
  emptyContainers = new Set(['defs', 'g', 'svg', 'switch', 'symbol']);

  preactRenderToDom = null;

  SVGContent = class SVGContent extends HasSettings {
    /*
    Base helper for parsing SVG as specified in SVG Tiler:
    SVG strings, Preact VDOM, or filenames, with special handling of image files.
    Automatically determines `width`, `height`, `viewBox`, `boundingBox`,
    and `zIndex` properties if specified in the SVG content,
    and sets `isEmpty` to indicate whether the SVG is a useless empty tag.
    In many cases (symbols and defs), acquires an `id` property via `setId`,
    which can be formatted via `url()` and `hash()`.
    In some cases, acquires `isStatic` Boolean property to indicate
    re-usable content, or `isForced` Boolean property to indicate
    a def that should be included by force (even if unused).
    */
    constructor(name1, value1, settings1) {
      super();
      this.name = name1;
      this.value = value1;
      this.settings = settings1;
    }

    url() {
      return `url(#${this.id})`;
    }

    hash() {
      return `#${this.id}`;
    }

    force(value = true) {
      this.isForced = value;
      return this;
    }

    makeSVG() {
      var extension, filename, ref, ref1, ref2, ref3, ref4;
      if (this.svg != null) {
        return this.svg;
      }
      //# Set `@svg` to SVG string for duplication detection.
      if (isPreact(this.value)) {
        //# Render Preact virtual dom nodes (e.g. from JSX notation) into strings
        //# and directly into DOM.
        this.svg = ((ref = typeof window !== "undefined" && window !== null ? (ref1 = window.preactRenderToString) != null ? ref1.default : void 0 : void 0) != null ? ref : require('preact-render-to-string'))(this.value);
        if (preactRenderToDom === null) {
          try {
            preactRenderToDom = (ref2 = typeof window !== "undefined" && window !== null ? (ref3 = window.preactRenderToDom) != null ? ref3.RenderToDom : void 0 : void 0) != null ? ref2 : require('preact-render-to-dom');
          } catch (error1) {}
          if (preactRenderToDom != null) {
            if (xmldom != null) {
              preactRenderToDom = new preactRenderToDom.RenderToXMLDom({
                xmldom,
                svg: true,
                skipNS: true
              });
            } else {
              preactRenderToDom = new preactRenderToDom.RenderToDom({
                svg: true
              });
            }
          }
        }
        if (preactRenderToDom != null) {
          this.dom = preactRenderToDom.render(this.value);
          this.postprocessDOM();
        }
      } else if (typeof this.value === 'string') {
        if (this.value.trim() === '') { //# Blank SVG mapped to empty <symbol>
          this.svg = '<symbol/>'; //# This will get width/height 0 in SVGSymbol
        } else if (!this.value.includes('<')) { //# No <'s -> interpret as filename
          filename = resolve((ref4 = this.settings) != null ? ref4.dirname : void 0, this.value);
          extension = extensionOf(filename);
          //# <image> tag documentation: "Conforming SVG viewers need to
          //# support at least PNG, JPEG and SVG format files."
          //# [https://svgwg.org/svg2-draft/embedded.html#ImageElement]
          switch (extension) {
            case '.png':
            case '.jpg':
            case '.jpeg':
            case '.gif':
              this.svg = `<image ${hrefAttr(this.settings)}="${encodeURI(this.value)}"/>`;
              break;
            case '.svg':
              this.filename = filename;
              this.settings = {
                ...this.settings,
                dirname: path.dirname(filename)
              };
              this.svg = loadSVG(this.filename, this.settings);
              this.svg = prefixSVGIds(this.svg, prefixForFilename(filename));
              break;
            default:
              throw new SVGTilerError(`Unrecognized extension in filename '${this.value}' for ${this.name}`);
          }
        } else {
          this.svg = this.value;
        }
      } else {
        throw new SVGTilerError(`Invalid value for ${this.name}: ${typeof this.value}`);
      }
      //# Remove initial SVG/XML comments (for broader duplication detection,
      //# and the next replace rule).
      return this.svg = removeSVGComments(this.svg);
    }

    setId(id1) {
      this.id = id1;
      if (this.dom != null) {
        //# Can be called before or after makeDOM, updating DOM in latter case.
        return this.dom.setAttribute('id', this.id);
      }
    }

    defaultId(base = 'id') {
      /*
      Generate a "default" id (typically for use in def) using these rules:
      1. If the root element has an `id` attribute, use that (manual spec).
      2. Use the root element's tag name, if any
      3. Fallback to use first argument `base`, which defaults to `"id"`.
      The returned id is not yet escaped; you should pass it to `escapeId`.
      */
      var doc;
      doc = this.makeDOM();
      return doc.getAttribute('id') || doc.tagName || base;
    }

    makeDOM() {
      var base1, error, msg, svg;
      if (this.dom != null) {
        return this.dom;
      }
      this.makeSVG();
      //# Force SVG namespace when parsing, so nodes have correct namespaceURI.
      //# (This is especially important on the browser, so the results can be
      //# reparented into an HTML Document.)
      svg = this.svg.replace(/^\s*<(?:[^<>'"\/]|'[^']*'|"[^"]*")*\s*(\/?\s*>)/, function(match, end) {
        if (!match.includes('xmlns')) {
          match = match.slice(0, match.length - end.length) + ` xmlns='${SVGNS}'` + match.slice(match.length - end.length);
        }
        return match;
      });
      this.dom = new DOMParser({
        locator: { //# needed when specifying errorHandler
          line: 1,
          col: 1
        },
        errorHandler: (level, msg, indent = '  ') => {
          msg = msg.replace(/^\[xmldom [^\[\]]*\]\t/, '');
          msg = msg.replace(/@#\[line:(\d+),col:(\d+)\]$/, (match, line, col) => {
            var lines;
            lines = svg.split('\n');
            return (line > 1 ? indent + lines[line - 2] + '\n' : '') + indent + lines[line - 1] + '\n' + indent + ' '.repeat(col - 1) + '^^^' + (line < lines.length ? '\n' + indent + lines[line] : '');
          });
          return console.error(`SVG parse ${level} in ${this.name}: ${msg}`);
        }
      }).parseFromString(svg, 'image/svg+xml').documentElement;
      // Web parser creates <parsererror> inside <html><body>
      if (error = typeof (base1 = this.dom).querySelector === "function" ? base1.querySelector('parsererror') : void 0) {
        msg = error.innerHTML.replace(/<h3[^<>]*>[^]*?<\/h3>/g, '').replace(/<\/?div[^<>]*>/g, '');
        this.dom = error.nextSibling;
        console.error(`SVG parse error in ${this.name}: ${msg}`);
      }
      this.postprocessDOM();
      return this.dom;
    }

    postprocessDOM() {
      var base1, base2, overflow, recursiveEmpty;
      if (typeof (base1 = this.dom).removeAttribute === "function") {
        base1.removeAttribute('xmlns');
      }
      if (!this.getSetting('useHref')) {
        if (typeof (base2 = this.dom).removeAttribute === "function") {
          base2.removeAttribute('xmlns:xlink');
        }
      }
      if (typeof this.wrap === "function") {
        this.wrap();
      }
      //# <image> processing (must come before width/height processing).
      domRecurse(this.dom, (node) => {
        /*
        Fix image-rendering: if unspecified, or if specified as "optimizeSpeed"
        or "pixelated", attempt to render pixels as pixels, as needed for
        old-school graphics.  SVG 1.1 and Inkscape define
        image-rendering="optimizeSpeed" for this.  Chrome doesn't support this,
        but supports a CSS3 (or SVG) specification of
        "image-rendering:pixelated".  Combining these seems to work everywhere.
        */
        var e, filedata, filename, height, href, imageRendering, key, ref, size, style, type, width;
        if (node.nodeName === 'image') {
          imageRendering = attributeOrStyle(node, 'image-rendering');
          if ((imageRendering == null) || (imageRendering === 'optimizeSpeed' || imageRendering === 'pixelated')) {
            node.setAttribute('image-rendering', 'optimizeSpeed');
            style = (ref = node.getAttribute('style')) != null ? ref : '';
            style = style.replace(/(^|;)\s*image-rendering\s*:\s*\w+\s*($|;)/, function(m, before, after) {
              return before || after || '';
            });
            if (style) {
              style += ';';
            }
            node.setAttribute('style', style + 'image-rendering:pixelated');
          }
          //# Read file for width/height detection and/or inlining
          ({href, key} = getHref(node));
          filename = resolve(this.settings.dirname, href);
          if ((filename != null) && !/^data:|file:|[a-z]+:\/\//.test(filename)) { // skip URLs
            filedata = null;
            try {
              if (typeof window === "undefined" || window === null) {
                filedata = fs.readFileSync(filename);
              }
            } catch (error1) {
              e = error1;
              console.warn(`Failed to read image '${filename}': ${e}`);
            }
            //# Fill in width and/or height if missing
            width = parseFloat(node.getAttribute('width'));
            height = parseFloat(node.getAttribute('height'));
            if ((isNaN(width)) || (isNaN(height))) {
              size = null;
              if ((filedata != null) && (typeof window === "undefined" || window === null)) {
                try {
                  size = require('image-size')(filedata != null ? filedata : filename);
                } catch (error1) {
                  e = error1;
                  console.warn(`Failed to detect size of image '${filename}': ${e}`);
                }
              }
              if (size != null) {
                //# If one of width and height is set, scale to match.
                if (!isNaN(width)) {
                  node.setAttribute('height', size.height * (width / size.width));
                } else if (!isNaN(height)) {
                  node.setAttribute('width', size.width * (height / size.height));
                } else {
                  //# If neither width nor height are set, set both.
                  node.setAttribute('width', size.width);
                  node.setAttribute('height', size.height);
                }
              }
            }
            //# Inline
            if ((filedata != null) && this.getSetting('inlineImages')) {
              type = contentType[extensionOf(filename)];
              if (type != null) {
                node.setAttribute("data-filename", path.basename(filename));
                if (size != null) {
                  node.setAttribute("data-width", size.width);
                  node.setAttribute("data-height", size.height);
                }
                node.setAttribute(key, `data:${type};base64,${filedata.toString('base64')}`);
              }
            }
          }
          return false;
        } else {
          return true;
        }
      });
      //# Determine whether the symbol is "empty",
      //# meaning it has no useful content so can be safely omitted.
      recursiveEmpty = function(node, allowId) {
        var child, l, len, ref;
        if (node.nodeType === node.TEXT_NODE) {
          return !node.data;
        }
        if (!(node.nodeType === node.DOCUMENT_FRAGMENT_NODE || emptyContainers.has(node.tagName))) {
          return false;
        }
        if (!(allowId || !(typeof node.hasAttribute === "function" ? node.hasAttribute('id') : void 0))) {
          //# `hasAttribute` won't be defined in the case node is DocumentFragment
          return false;
        }
        ref = node.childNodes;
        for (l = 0, len = ref.length; l < len; l++) {
          child = ref[l];
          if (!recursiveEmpty(child)) {
            return false;
          }
        }
        return true;
      };
      this.isEmpty = recursiveEmpty(this.dom, this.emptyWithId);
      //# Determine `viewBox`, `width`, and `height` attributes.
      this.viewBox = parseBox(this.dom.getAttribute('viewBox'));
      this.width = parseDim(this.origWidth = this.dom.getAttribute('width'));
      this.height = parseDim(this.origHeight = this.dom.getAttribute('height'));
      //# Check for default width/height specified by caller.
      if ((this.width == null) && (this.defaultWidth != null)) {
        this.dom.setAttribute('width', this.width = this.defaultWidth);
      }
      if ((this.height == null) && (this.defaultHeight != null)) {
        this.dom.setAttribute('height', this.height = this.defaultHeight);
      }
      //# Absent viewBox becomes 0 0 <width> <height> if latter are present
      //# (but only internal to SVG Tiler, DOM remains unchanged).
      if ((this.width != null) && (this.height != null) && (this.viewBox == null) && this.autoViewBox) {
        this.viewBox = [0, 0, this.width, this.height];
      }
      //# Absent viewBox set to automatic bounding box if requested
      //# (e.g. in `SVGSymbol`).
      if ((this.viewBox == null) && this.autoViewBox) {
        //# Treat empty content (e.g. empty fragment) as 0x0.
        if (this.isEmpty) {
          this.viewBox = [0, 0, 0, 0];
          this.dom.setAttribute('viewBox', this.viewBox.join(' '));
        } else if ((this.viewBox = svgBBox(this.dom)) != null) {
          this.dom.setAttribute('viewBox', this.viewBox.join(' '));
        }
      }
      //# Absent width/height inherited from viewBox if latter is present,
      //# in `SVGSymbol` which sets `@autoWidthHeight`.
      //# Including the width/height in the <symbol> lets us skip it in <use>.
      if ((this.viewBox != null) && this.autoWidthHeight) {
        if (this.width == null) {
          this.dom.setAttribute('width', this.width = this.viewBox[2]);
        }
        if (this.height == null) {
          this.dom.setAttribute('height', this.height = this.viewBox[3]);
        }
      }
      //# Overflow behavior
      overflow = attributeOrStyle(this.dom, 'overflow');
      if ((overflow == null) && (this.defaultOverflow != null)) {
        this.dom.setAttribute('overflow', overflow = this.defaultOverflow);
      }
      this.overflowVisible = (overflow != null) && /^\s*(visible|scroll)\b/.test(overflow);
      /*
      SVG's `viewBox`, `width`, and `height` attributes have a special rule that
      "A value of zero disables rendering of the element."
      [https://www.w3.org/TR/SVG11/coords.html#ViewBoxAttribute]
      [https://www.w3.org/TR/SVG11/struct.html#SVGElementWidthAttribute]
      Avoid this if overflow is visible.
      */
      if (this.overflowVisible) {
        if (this.width === 0) {
          this.dom.setAttribute('width', zeroSizeReplacement);
        }
        if (this.height === 0) {
          this.dom.setAttribute('height', zeroSizeReplacement);
        }
        if ((this.viewBox != null) && (this.viewBox[2] === 0 || this.viewBox[3] === 0)) {
          if (this.viewBox[2] === 0) {
            this.viewBox[2] = zeroSizeReplacement;
          }
          if (this.viewBox[3] === 0) {
            this.viewBox[3] = zeroSizeReplacement;
          }
          this.dom.setAttribute('viewBox', this.viewBox.join(' '));
        }
      }
      //# Special SVG Tiler attributes that get extracted from DOM
      this.boundingBox = extractBoundingBox(this.dom);
      this.zIndex = extractZIndex(this.dom);
    }

    //@isEmpty = @dom.childNodes.length == 0 and
    //  (@emptyWithId or not @dom.hasAttribute 'id') and
    //  emptyContainers.has @dom.tagName
    useDOM() {
      this.makeDOM();
      if (this.idOverride != null) {
        //# `@idOverride` sets `id` attribute just in the used DOM,
        //# without changing the `@id` property of the `SVGContent` object.
        this.dom.setAttribute('id', this.idOverride);
      }
      //# Clone if content is static, to enable later re-use
      if (this.isStatic) {
        return this.dom.cloneNode(true);
      } else {
        return this.dom;
      }
    }

  };

  SVGWrapped = class SVGWrapped extends SVGContent {
    /*
    Abstract base class for `SVGSymbol` and `SVGSVG` which automatically wrap
    content in a containing element (`<symbol>` or `<svg>` respectively).
    Subclass should define `wrapper` of 'symbol' or 'svg'.
    Parser will enforce that the content is wrapped in this element.
    */
    wrap() {
      var attribute, base1, child, l, len, len1, len2, n, node, o, parent, ref, ref1, ref2, ref3, ref4, ref5, ref6, symbol;
      //# Wrap XML in <wrapper>.
      symbol = this.dom.ownerDocument.createElementNS(SVGNS, this.wrapper);
      //# Force `id` to be first attribute.
      symbol.setAttribute('id', this.id || '');
      //# Avoid a layer of indirection for <symbol>/<svg> at top level
      if ((ref = this.dom.nodeName) === 'symbol' || ref === 'svg') {
        ref1 = this.dom.attributes;
        for (l = 0, len = ref1.length; l < len; l++) {
          attribute = ref1[l];
          if (!(((ref2 = attribute.name) === 'version' || ref2 === 'id') || attribute.name.startsWith('xmlns'))) {
            symbol.setAttribute(attribute.name, attribute.value);
          }
        }
        ref3 = (function() {
          var len1, o, ref3, results;
          ref3 = this.dom.childNodes;
          results = [];
          for (o = 0, len1 = ref3.length; o < len1; o++) {
            node = ref3[o];
            results.push(node);
          }
          return results;
        }).call(this);
        for (n = 0, len1 = ref3.length; n < len1; n++) {
          child = ref3[n];
          symbol.appendChild(child);
        }
        if ((ref4 = this.dom.parentNode) != null) {
          ref4.replaceChild(symbol, this.dom);
        }
      } else {
        ref5 = ['viewBox', 'boundingBox', 'z-index', 'overflow', 'width', 'height'];
        //# Allow top-level object to specify <symbol> data.
        for (o = 0, len2 = ref5.length; o < len2; o++) {
          attribute = ref5[o];
          if ((attribute === 'width' || attribute === 'height') && ((ref6 = this.dom.tagName) !== 'g')) {
            //# `width` and `height` have another meaning in e.g. <rect>s,
            //# so just transfer for tags where they are meaningless.
            continue;
          }
          if (typeof (base1 = this.dom).hasAttribute === "function" ? base1.hasAttribute(attribute) : void 0) {
            symbol.setAttribute(attribute, this.dom.getAttribute(attribute));
            this.dom.removeAttribute(attribute);
          }
        }
        parent = this.dom.parentNode;
        symbol.appendChild(this.dom);
        if (parent != null) {
          parent.appendChild(symbol);
        }
      }
      return this.dom = symbol;
    }

  };

  SVGSymbol = (function() {
    //class SVGSVG extends SVGWrapped
    //  ###
    //  SVG content wrapped in `<svg>`.
    //  ###
    //  wrapper: 'svg'
    class SVGSymbol extends SVGWrapped {
      postprocessDOM() {
        var warnings;
        //# Special defaults for loading symbols in `SVGContent`'s `makeDOM`.
        this.defaultWidth = this.getSetting('forceWidth');
        this.defaultHeight = this.getSetting('forceHeight');
        this.defaultOverflow = this.getSetting('overflowDefault');
        //# `SVGContent` sets `@width` and `@height` according to
        //# `width`/`height`/`viewBox` attributes or our defaults.
        super.postprocessDOM();
        //# Detect special `width="auto"` and/or `height="auto"` fields for future
        //# processing, and remove them to ensure valid SVG.
        this.autoWidth = isAuto(this.origWidth);
        this.autoHeight = isAuto(this.origHeight);
        if (this.autoWidth) {
          //# Remove `width="auto"` and `height="auto"` attributes
          //# (or whatever `SVGContent` set them to).
          this.dom.removeAttribute('width');
        }
        if (this.autoHeight) {
          this.dom.removeAttribute('height');
        }
        //# Warning for missing width/height.
        warnings = [];
        if (this.width == null) {
          warnings.push('width');
          this.width = 0;
        }
        if (this.height == null) {
          warnings.push('height');
          this.height = 0;
        }
        if (warnings.length) {
          this.sizeWarning = function() {
            return console.warn(`Failed to detect ${warnings.join(' and ')} of SVG for ${this.name}`);
          };
        }
        //# Optionally extract <text> nodes for LaTeX output
        if (this.getSetting('texText')) {
          this.text = [];
          domRecurse(this.dom, (node, parent) => {
            if (node.nodeName === 'text') {
              this.text.push(node);
              node.parentNode.removeChild(node);
              return false; // don't recurse into <text>'s children
            } else {
              return true;
            }
          });
        }
        return this.dom;
      }

    };

    /*
    SVG content wrapped in `<symbol>`, with special width/height handling
    and text extraction, used for tiles.
    Note though that one `SVGSymbol` may be re-used in many different `Tile`s.
    */
    SVGSymbol.prototype.wrapper = 'symbol';

    SVGSymbol.prototype.autoViewBox = true;

    SVGSymbol.prototype.autoWidthHeight = true;

    SVGSymbol.prototype.emptyWithId = true; // consider empty even if <symbol> has id attribute

    return SVGSymbol;

  }).call(this);

  //# Tile to fall back to when encountering an unrecognized key.
  //# Path from https://commons.wikimedia.org/wiki/File:Replacement_character.svg
  //# by Amit6, released into the public domain.
  unrecognizedSymbol = new SVGSymbol('unrecognized tile', `<symbol viewBox="0 0 200 200" preserveAspectRatio="none" width="auto" height="auto">
  <rect width="200" height="200" fill="yellow"/>
  <path stroke="none" fill="red" d="M 200,100 100,200 0,100 100,0 200,100 z M 135.64709,74.70585 q 0,-13.52935 -10.00006,-22.52943 -9.99999,-8.99999 -24.35289,-8.99999 -17.29415,0 -30.117661,5.29409 L 69.05879,69.52938 q 9.764731,-6.23528 21.52944,-6.23528 8.82356,0 14.58824,4.82351 5.76469,4.82351 5.76469,12.70589 0,8.5883 -9.94117,21.70588 -9.94117,13.11766 -9.94117,26.76473 l 17.88236,0 q 0,-6.3529 6.9412,-14.9412 11.76471,-14.58816 12.82351,-16.35289 6.9412,-11.05887 6.9412,-23.29417 z m -22.00003,92.11771 0,-24.70585 -27.29412,0 0,24.70585 27.29412,0 z"/>
</symbol>`);

  unrecognizedSymbol.id = '_unrecognized'; // cannot be output of escapeId()

  unrecognizedSymbol.isStatic = true; // need to clone on use

  
  //# Tile to fall back to when encountering an error during tile evaluation.
  //# Path from https://commons.wikimedia.org/wiki/File:Caution_icon_-_Noun_Project_9556_white.svg
  //# by José Hernandez, SE, released under CC-BY-SA 3.0.
  //# This symbol is hereby released under the same CC-BY-SA 3.0 license.
  errorSymbol = new SVGSymbol('error tile', `<symbol viewBox="0 0 100 100" preserveAspectRatio="none" width="auto" height="auto">
  <rect width="100" height="100" fill="yellow"/>
  <path stroke="none" fill="red" d="M96.803,83.551L55.418,8.992C52.466,3.67,47.631,3.67,44.675,8.988L3.23,83.555   c-2.957,5.32-0.396,9.672,5.688,9.672h82.19C97.193,93.227,99.756,88.873,96.803,83.551z M55.53,82.439H44.5V71.41h11.03V82.439z    M56.064,38.449l-2.484,26.85h-7.132l-2.484-26.85v-9.894h12.101V38.449z"/>
</symbol>`);

  errorSymbol.id = '_error'; // cannot be output of escapeId()

  errorSymbol.isStatic = true; // need to clone on use

  Input = (function() {
    class Input extends HasSettings {
      /*
      Abstract base class for all inputs to SVG Tiler, in particular
      `Mapping`, `Style`, and `Drawing` and their format-specific subclasses.

      Each subclass should define:
      * `parse(data)` method that parses the input contents in the format
        defined by the subclass (specified manually by the user, or
        automatically read from the input file).
      * `skipRead: true` attribute if you don't want `@parseFile` class method
        to read the file data and pass it into `parse`, in case you want to read
        from `@filename` directly yourself in a specific way.
       */
      constructor(data, opts) {
        var key, value;
        /*
        `data` is input-specific data for direct creation (e.g. without a file),
        which is processed via a `parse` method (which subclass must define).
        `opts` is an object with options attached directly to the Input
        (*before* `parse` gets called), including `filename` and `settings`.
        */
        super();
        if (opts != null) {
          for (key in opts) {
            value = opts[key];
            this[key] = value;
          }
        }
        this.parse(data);
      }

      static parseFile(filename, filedata, settings) {
        /*
        Generic method to parse file once we're already in the correct subclass.
        Automatically reads the file contents from `filename` unless
        * `@skipRead` is true, or
        * file contents are specified via `settings.filedata`.
          Use this to avoid attempting to use the file system on the browser.
         */
        var modified;
        modified = -2e308;
        try {
          modified = (fs.statSync(filename)).mtimeMs;
        } catch (error1) {}
        if (!((filedata != null) || this.skipRead)) {
          filedata = fs.readFileSync(filename, {
            encoding: this.encoding
          });
        }
        return new this(filedata, {filename, modified, settings});
      }

      static recognize(filename, filedata, settings) {
        var extension;
        /*
        Recognize type of file and call corresponding class's `parseFile`.
        Meant to be used as `Input.recognize(...)` via top-level Input class,
        without specific subclass.
        */
        if (extensionMap.hasOwnProperty((extension = extensionOf(filename)))) {
          return extensionMap[extension].parseFile(filename, filedata, settings);
        } else {
          //else if filenameMap.hasOwnProperty (lower = filename.toLowerCase())
          //  filenameMap[lower].parseFile filename, filedata, settings
          throw new SVGTilerError(`Unrecognized extension in filename ${filename}`);
        }
      }

      dependsOn(deps1) {
        var dep, l, len, modified, ref, results;
        this.deps = deps1;
        ref = this.deps;
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          dep = ref[l];
          try {
            modified = (fs.statSync(dep)).mtimeMs;
          } catch (error1) {}
          if (modified == null) {
            continue;
          }
          results.push(this.modified = Math.max(this.modified, modified));
        }
        return results;
      }

      generateFilename(ext, filename = this.filename, subname = this.subname) {
        var outputDir, outputStem, ref;
        filename = path.parse(filename);
        delete filename.base; // force generation from filename.name & filename.ext
        if ((outputStem = this.getSetting('outputStem')) != null) {
          filename.name = outputStem.replace('*', filename.name);
        }
        if (subname) {
          filename.name += ((ref = this.filenameSeparator) != null ? ref : '') + subname;
        }
        if (filename.ext === ext) {
          filename.ext += ext;
        } else {
          filename.ext = ext;
        }
        if ((outputDir = this.getOutputDir(ext)) != null) {
          filename.dir = outputDir;
        }
        return path.format(filename);
      }

    };

    Input.encoding = 'utf8';

    Input.prototype.filenameSeparator = '_';

    return Input;

  }).call(this);

  Style = class Style extends Input {
    /*
    Base Style class assumes any passed data is in CSS format,
    stored in `@css` attribute.
    */
    parse(css) {
      this.css = css;
    }

  };

  CSSStyle = (function() {
    class CSSStyle extends Style {};

    //# Style in CSS format.  Equivalent to Style base class.
    CSSStyle.title = "CSS style file";

    return CSSStyle;

  }).call(this);

  StylusStyle = (function() {
    class StylusStyle extends Style {
      parse(stylus) {
        var styl;
        styl = require('stylus')(stylus, {
          filename: this.filename
        });
        return super.parse(styl.render());
      }

    };

    //# Style in Stylus format.
    StylusStyle.title = "Stylus style file (https://stylus-lang.com/)";

    return StylusStyle;

  }).call(this);

  ArrayWrapper = class ArrayWrapper extends Array {
    /*
    Array-like object (indeed, Array subclass) where each item in the array
    is supposed to be of a fixed class, given by the `@itemClass` class attribute.
    For example, `Styles` is like an array of `Style`s; and
    `Mappings` is like an array of `Mapping`s.
    */
    constructor(...items) {
      var item, l, len;
      /*
      Enforce `items` to be instances of `@itemClass`.
      Supported formats:
        * `ArrayWrapper` (just clone array)
        * `@itemClass` (wrap in singleton)
        * raw data to pass to `new @itemClass`
        * `Array` of `@itemClass`
        * `Array` of raw data to pass to `new @itemClass`
        * `Array` of a mixture
        * `undefined`/`null` (empty)
       */
      super();
      for (l = 0, len = items.length; l < len; l++) {
        item = items[l];
        if (item instanceof this.constructor) {
          this.push(...item);
        } else if (item instanceof this.constructor.itemClass) {
          this.push(item);
        } else {
          this.push(new this.constructor.itemClass(item));
        }
      }
    }

  };

  Styles = (function() {
    class Styles extends ArrayWrapper {};

    Styles.itemClass = Style;

    return Styles;

  }).call(this);

  parseIntoArgs = function(text) {
    var arg, args, chunk, match, re, ref;
    //# Parse string into an array of arguments, similar to shells.
    re = /"(?:[^"\\]|\\.)*"|'[^']*'?|\\.|\#.*|(\s+)|[^"'\\\#\s]+|./g; // double-quoted string
    // single-quoted string: no escape processing
    // escaped character
    // comment
    // top-level whitespace separates args
    // everything else
    // for failed matches like "foo
    args = [];
    arg = '';
    while ((match = re.exec(text)) != null) {
      chunk = match[0];
      if (match[1]) {
        if (arg) {
          args.push(arg);
        }
        arg = '';
      } else {
        switch (chunk[0]) {
          case '"':
            //# Double-quoted strings escape all glob patterns, and
            //# process argument-specific escapes processed,
            //# leaving rest (e.g. `\*`) for glob processing.
            chunk = chunk.slice(1, -1).replace(/\\(["'\-#])/g, '$1').replace(/[\*\+\?\!\|\@\(\)\[\]\{\}]/g, '\\$&');
            break;
          case "'":
            //# Single-quoted strings escape all backslashes and glob patterns
            //# so they will be treated literally (as in bash).
            chunk = chunk.slice(1, -1).replace(/[\\\*\+\?\!\|\@\(\)\[\]\{\}]/g, '\\$&');
            break;
          case '\\':
            if ((ref = chunk[1]) === '"' || ref === "'" || ref === '-' || ref === '#') {
              //# Process escaping specific to argument parsing,
              //# leaving rest (e.g. `\*`) for glob processing.
              chunk = chunk[1];
            }
            break;
          case '#':
            continue;
        }
        arg += chunk;
      }
    }
    if (arg) {
      args.push(arg);
    }
    return args;
  };

  Args = class Args extends Input {
    /*
    Base args list stores in `@args` an array of strings
    such as "-p" and "filename.asc".
    */
    parse(args1) {
      this.args = args1;
    }

    doInit() {}

    makeRule(key) {
      //# Only default rule '' defined by Args.
      if (key) {
        return;
      }
      //# Run child driver with arguments.
      svgtiler(this.args);
      return true;
    }

  };

  ParsedArgs = (function() {
    class ParsedArgs extends Args {
      parse(text) {
        return super.parse(parseIntoArgs(text));
      }

    };

    /*
    `.args` files are represented as an ASCII file that's parsed like a shell,
    allowing quoted strings, backslash escapes, comments via `#`, and
    newlines treated like regular whitespace.
    */
    ParsedArgs.title = "Additional command-line arguments parsed like a shell";

    return ParsedArgs;

  }).call(this);

  multiCall = function(func, arg) {
    var item, l, len, ref, results;
    //# Call function with this and first argument set to `arg`.
    //# Allow arrays as shorthand for multiple functions to call.
    if (func == null) {
      return;
    }
    if (Array.isArray(arg)) {
      ref = arg.flat(2e308);
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        item = ref[l];
        results.push(func.call(arg, arg));
      }
      return results;
    } else {
      return func.call(arg, arg);
    }
  };

  Mapping = (function() {
    class Mapping extends Input {
      constructor(data, opts) {
        super(data, opts);
        if (this.cache == null) {
          this.cache = new Map(); // for static tiles
        }
        if (this.filename != null) {
          this.settings = {
            ...this.settings,
            dirname: path.dirname(this.filename)
          };
        }
      }

      parse(data) {
        var defaultMap, ref;
        if (typeof data === 'function' || data instanceof Map || data instanceof WeakMap || Array.isArray(data)) {
          data = {
            map: data
          };
        }
        if (data != null) {
          ({
            map: this.map,
            init: this.init,
            preprocess: this.preprocess,
            postprocess: this.postprocess,
            default: defaultMap
          } = data);
          if (this.map == null) {
            this.map = defaultMap; // use `default` if no `map` property
          }
        }
        if ((ref = typeof this.map) !== 'function' && ref !== 'object' && ref !== 'undefined') {
          console.warn(`Mapping file ${this.filename} returned invalid mapping data of type (${typeof this.map}): should be function or object`);
          this.map = null;
        }
        if (isPreact(this.map)) {
          console.warn(`Mapping file ${this.filename} returned invalid mapping data (Preact DOM): should be function or object`);
          return this.map = null;
        }
      }

      lookup(key, context) {
        var found, isStatic, recurse, symbol, value;
        //# `key` normally should be a String (via `AutoDrawing::parse` coercion).
        //# Don't do anything if this is an empty mapping.
        if (this.map == null) {
          return;
        }
        //# Check cache (used for static tiles).
        if ((found = this.cache.get(key)) != null) {
          return found;
        }
        //# Repeatedly expand `@map` until we get string, Preact VDOM, or
        //# null/undefined.  Arrays get expanded recursively.
        recurse = (value, isStatic = void 0) => {
          var allStatic, item, result;
          while (value != null) {
            //console.log key, (
            //  switch
            //    when Array.isArray value then 'array'
            //    when isPreact value then 'preact'
            //    else typeof value
            //), isStatic
            if (typeof value === 'string' || isPreact(value)) {
              //# Static unless we saw a function and no static wrapper.
              if (isStatic == null) {
                isStatic = true;
              }
              //# Symbol ends up getting `isStatic` set to global `isStatic` value,
              //# instead of this local value.  For example, not helpful to mark
              //# this symbol as static if another one in an array isn't static.
              value = new SVGSymbol(`tile '${key}'`, value, this.settings);
              //value.isStatic = isStatic
              return {value, isStatic};
            } else if (value instanceof Map || value instanceof WeakMap) {
              value = value.get(key);
            } else if (typeof value === 'function') {
              value = value.call(context, key, context);
              //# Use of a function implies dynamic, unless there's a static wrapper.
              if (isStatic == null) {
                isStatic = false;
              }
            } else if ($static in value) { // static wrapper from wrapStatic
              value = value[$static];
              //# Static wrapper forces static, even if there are functions.
              isStatic = true;
            } else if (value instanceof Mapping || value instanceof Mappings) {
              return {
                value: value.lookup(key, context),
                isStatic: false // no need to cache at higher level
              };
            } else if (Array.isArray(value)) { // must come after Mappings test
              //# Items in an array inherit parent staticness if any,
              //# with no influence between items.
              //# Overall array is static if every item is.
              allStatic = true;
              value = (function() {
                var l, len, results;
                results = [];
                for (l = 0, len = value.length; l < len; l++) {
                  item = value[l];
                  result = recurse(item, isStatic);
                  if (result.isStatic === false) {
                    allStatic = false;
                  }
                  results.push(result.value);
                }
                return results;
              })();
              return {
                value,
                isStatic: allStatic
              };
            } else if (typeof value === 'object') {
              if (value.hasOwnProperty(key)) { // avoid inherited property e.g. toString
                value = value[key];
              } else {
                value = void 0;
              }
            } else {
              console.warn(`Unsupported data type ${typeof value} in looking up tile '${key}'`);
              value = void 0;
            }
          }
          //# Static unless we saw a function and no static wrapper
          if (isStatic == null) {
            isStatic = true;
          }
          return {value, isStatic};
        };
        ({value, isStatic} = recurse(this.map));
        //# Set each symbol's `isStatic` flag to the global `isStatic` value.
        //# Enforce arrays to be flat with no nulls.
        if (Array.isArray(value)) {
          value = (function() {
            var l, len, ref, results;
            ref = value.flat(2e308);
            results = [];
            for (l = 0, len = ref.length; l < len; l++) {
              symbol = ref[l];
              if (!(symbol != null)) {
                continue;
              }
              symbol.isStatic = isStatic;
              results.push(symbol);
            }
            return results;
          })();
        } else if (value != null) {
          value.isStatic = isStatic;
        }
        if (isStatic) {
          //# Save in cache if overall static.
          this.cache.set(key, value);
        }
        return value;
      }

      makeRule(key) {
        var executed, recurse, ref, ref1, ref2;
        executed = false;
        recurse = (value, usedKey) => {
          var item, l, len;
          while (value != null) {
            //if typeof value == 'string'
            //  run value
            //  executed = true
            //  return
            if (value instanceof Map || value instanceof WeakMap) {
              value = value.get(key);
              usedKey = true;
            } else if (typeof value === 'function') {
              //# Functions without arguments only match default rule '',
              //# unless we've already used the rule through object or Map lookup.
              if (key && !usedKey && !value.length) {
                return;
              }
              value = value.call(this, key, this);
              if (value !== null) {
                //# Function can return `null` (not `undefined`) to say 'no rule'.
                executed = true;
              }
              return;
            } else if (Array.isArray(value)) {
              for (l = 0, len = value.length; l < len; l++) {
                item = value[l];
                recurse(item, usedKey);
              }
              return;
            } else if (typeof value === 'object') {
              if (value.hasOwnProperty(key)) { // avoid inherited property e.g. toString
                value = value[key];
                usedKey = true;
              } else {
                value = void 0;
              }
            } else {
              console.warn(`Unsupported data type ${typeof value} in looking up Maketile rule '${key}'`);
              value = void 0;
            }
          }
          return value;
        };
        recurse((ref = (ref1 = this.exports) != null ? ref1.make : void 0) != null ? ref : (ref2 = this.exports) != null ? ref2.default : void 0);
        return executed;
      }

      doInit() {
        if (this.getSetting('verbose') && (this.init != null)) {
          console.log(`# Calling init() in ${this.filename}`);
        }
        return multiCall(this.init, this);
      }

      doPreprocess(render) {
        if (this.getSetting('verbose') && (this.preprocess != null)) {
          console.log(`# Calling preprocess() in ${this.filename}`);
        }
        return multiCall(this.preprocess, render);
      }

      doPostprocess(render) {
        if (this.getSetting('verbose') && (this.postprocess != null)) {
          console.log(`# Calling postprocess() in ${this.filename}`);
        }
        return multiCall(this.postprocess, render);
      }

    };

    /*
    Base Mapping class.
    The passed-in data should be an object (or another `Mapping`)
    representing the exports from a JavaScript mapping file.
    The following object properties are optional:

    * `map`: an object, a Map, or a function resolving to one of the above
      or a String (containing SVG or a filename), Preact VDOM, or null/undefined,
      with Arrays possibly mixed in; or another `Mapping`.
    * `init`: function called when this mapping file gets instantiated.
    * `preprocess`: function called with a `Render` instance at the beginning.
    * `postprocess`: function called with a `Render` instance at the end.

    As shorthand, you can pass in just a Map, Array, or function and
    it will be treated as a `map`.

    In this class and subclasses, `@map`, `@init`, `@preprocess`, and
    `@postprocess` store this data.
     */
    Mapping.properties = ['map', 'init', 'preprocess', 'postprocess'];

    return Mapping;

  }).call(this);

  //# A fake Mapping file that just sets a `share` key when initialized.
  //# (Used to implement -s/--share command-line option.)
  ShareSetter = class ShareSetter extends Mapping {
    constructor(key, value, settings) {
      super({
        init: function() {
          return globalShare[key] = value;
        }
      }, {
        settings,
        filename: `--share ${key}=${value}`
      });
    }

  };

  ASCIIMapping = (function() {
    class ASCIIMapping extends Mapping {
      parse(data) {
        var key, l, len, line, map, ref, separator;
        map = {};
        ref = splitIntoLines(data);
        for (l = 0, len = ref.length; l < len; l++) {
          line = ref[l];
          separator = whitespace.exec(line);
          if (separator == null) {
            continue;
          }
          if (separator.index === 0) {
            if (separator[0].length === 1) {
              //# Single whitespace character at beginning defines blank character
              key = '';
            } else {
              //# Multiple whitespace at beginning defines first whitespace character
              key = line[0];
            }
          } else {
            key = line.slice(0, separator.index);
          }
          map[key] = line.slice(separator.index + separator[0].length);
        }
        return super.parse({map});
      }

    };

    ASCIIMapping.title = "ASCII mapping file";

    ASCIIMapping.help = "Each line is <tile-name><space><raw SVG or filename.svg>";

    return ASCIIMapping;

  }).call(this);

  JSMapping = (function() {
    class JSMapping extends Mapping {
      parse(data) {
        var _dirname, _filename, code, filename, func;
        if (data == null) {
          //# Normally use `require` to load code as a real NodeJS module
          filename = path.resolve(this.filename);
          //# Debug Babel output
          //if @constructor == JSMapping
          //  {code} = require('@babel/core').transform fs.readFileSync(filename), {
          //    ...babelConfig
          //    filename: @filename
          //  }
          //  console.log code
          if (pirates != null) {
            pirates.settings = this.settings;
          }
          //@exports = runWithMapping @, -> require filename
          this.exports = require(filename);
          this.walkDeps(filename);
        } else {
          //# But if file has been explicitly loaded (e.g. in browser),
          //# compile manually and simulate module.
          //console.log filename, @exports
          ({code} = require('@babel/core').transform(data, {
            ...babelConfig,
            filename: this.filename
          }));
          //console.log code
          this.exports = {};
          //# Mimick NodeJS module's __filename and __dirname variables
          //# [https://nodejs.org/api/modules.html#modules_the_module_scope]
          _filename = path.resolve(this.filename);
          _dirname = path.dirname(_filename);
          //# Use `new Function` instead of `eval` for improved performance and to
          //# restrict to passed arguments + global scope.
          //super eval code
          func = new Function('exports', '__filename', '__dirname', 'svgtiler', 'preact', code);
          //runWithMapping @, ->
          func(this.exports, _filename, _dirname, svgtiler, (code.includes('preact') ? require('preact') : void 0));
        }
        if (this.getSetting('verbose')) {
          console.log(`# Module ${this.filename} exported {${Object.keys(this.exports).join(', ')}}`);
        }
        return super.parse(this.exports);
      }

      walkDeps(filename) {
        var dep, deps, recurse;
        deps = new Set();
        recurse = (modname) => {
          var dep, l, len, ref, ref1, ref2, results;
          deps.add(modname);
          ref2 = (ref = (ref1 = require.cache[modname]) != null ? ref1.deps : void 0) != null ? ref : [];
          results = [];
          for (l = 0, len = ref2.length; l < len; l++) {
            dep = ref2[l];
            if (!deps.has(dep)) {
              results.push(recurse(dep));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
        recurse(filename);
        return this.dependsOn((function() {
          var results;
          results = [];
          for (dep of deps) {
            results.push(dep);
          }
          return results;
        })());
      }

    };

    JSMapping.title = "JavaScript mapping file (including JSX notation)";

    JSMapping.help = "Object mapping tile names to TILE e.g. {dot: 'dot.svg'}";

    JSMapping.skipRead = true; // `require` loads file contents for us

    return JSMapping;

  }).call(this);

  CoffeeMapping = (function() {
    class CoffeeMapping extends JSMapping {
      parse(data) {
        if (data == null) {
          //# Debug CoffeeScript output
          //{code} = require('@babel/core').transform(
          //  require('coffeescript').compile(
          //    fs.readFileSync(@filename, encoding: 'utf8'),
          //    bare: true
          //    inlineMap: true
          //    filename: @filename
          //    sourceFiles: [@filename])
          //  {...babelConfig, filename: @filename})
          //console.log code
          //# Normally rely on `require` and `CoffeeScript.register` to load code.
          return super.parse(data);
        } else {
          //# But if file has been explicitly loaded (e.g. in browser),
          //# compile manually.
          return super.parse(require('coffeescript').compile(data, {
            bare: true,
            inlineMap: true,
            filename: this.filename,
            sourceFiles: [this.filename]
          }));
        }
      }

    };

    CoffeeMapping.title = "CoffeeScript mapping file (including JSX notation)";

    CoffeeMapping.help = "Object mapping tile names to TILE e.g. dot: 'dot.svg'";

    return CoffeeMapping;

  }).call(this);

  Mappings = (function() {
    class Mappings extends ArrayWrapper {
      lookup(key, context) {
        var i, l, ref, value;
        if (!this.length) {
          return;
        }
        for (i = l = ref = this.length - 1; (ref <= 0 ? l <= 0 : l >= 0); i = ref <= 0 ? ++l : --l) {
          value = this[i].lookup(key, context);
          if (value != null) {
            return value;
          }
        }
        return void 0;
      }

      doPreprocess(render) {
        var l, len, mapping, ref, results;
        ref = this;
        //# Run mappings' preprocessing in forward order.
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          mapping = ref[l];
          results.push(mapping.doPreprocess(render));
        }
        return results;
      }

      doPostprocess(render) {
        var i, l, ref, results;
        //# Run mappings' postprocessing in reverse order.
        if (!this.length) {
          return;
        }
        results = [];
        for (i = l = ref = this.length - 1; (ref <= 0 ? l <= 0 : l >= 0); i = ref <= 0 ? ++l : --l) {
          results.push(this[i].doPostprocess(render));
        }
        return results;
      }

    };

    Mappings.itemClass = Mapping;

    return Mappings;

  }).call(this);

  blankCells = new Set([
    '',
    ' ' //# for ASCII art in particular
  ]);

  allBlank = function(list) {
    var l, len, x;
    for (l = 0, len = list.length; l < len; l++) {
      x = list[l];
      if ((x != null) && !blankCells.has(x)) {
        return false;
      }
    }
    return true;
  };

  hrefAttr = function(settings) {
    if (getSetting(settings, 'useHref')) {
      return 'href';
    } else {
      return 'xlink:href';
    }
  };

  maybeWrite = function(filename, data) {
    try {
      //# Writes data to filename, unless the file is already identical to data.
      //# Returns whether the write actually happened.
      if (data === fs.readFileSync(filename, {
        encoding: 'utf8'
      })) {
        return false;
      }
    } catch (error1) {}
    fs.writeFileSync(filename, data);
    return true;
  };

  /*
  This was a possible replacement for calls to maybeWrite, to prevent future
  calls from running the useless job again, but it doesn't interact well with
  PDF/PNG conversion: svgink will think it needs to convert.

  writeOrTouch = (filename, data) ->
    ## Writes data to filename, unless the file is already identical to data,
    ## in which case it touches the file (so that we don't keep regenerating it).
    ## Returns whether the write actually happened.
    wrote = maybeWrite filename, data
    unless wrote
      now = new Date
      fs.utimesSync filename, now, now
    wrote
   */
  Drawing = class Drawing extends Input {
    /*
    Base Drawing class uses a data format of an Array of Array of keys,
    where `@keys[i][j]` represents the key in row `i` and column `j`,
    without any preprocessing.  This is meant for direct API use,
    whereas AutoDrawing provides preprocessing for data from mapping files.
    In this class and subclasses, `@keys` stores the Array of Array of keys.
    */
    parse(keys) {
      this.keys = keys;
    }

    renderDOM(settings = this.settings) {
      return new Render(this, settings).makeDOM();
    }

    render(settings = this.settings) {
      var filename, r;
      //# Writes SVG and optionally TeX file.
      //# Returns output SVG filename.
      r = new Render(this, settings);
      filename = r.writeSVG();
      if (getSetting(settings, 'texText')) {
        r.writeTeX();
      }
      return filename;
    }

    get(j, i) {
      var ref;
      //# No special negative number handling
      return (ref = this.keys[i]) != null ? ref[j] : void 0;
    }

    set(j, i, key) {
      var row;
      if (i < 0 || j < 0) {
        throw new SVGTilerError(`Cannot set key for negative index (${i}, ${j})`);
      }
      while (i >= this.keys.length) {
        this.keys.push([]);
      }
      row = this.keys[i];
      while (j >= row.length) {
        row.push('');
      }
      return row[j] = key;
    }

    at(j, i) {
      var ref, ref1, ref2;
      //# Negative numbers wrap around
      if (i < 0) {
        i += this.keys.length;
      }
      if (j < 0) {
        j += (ref = (ref1 = this.keys[i]) != null ? ref1.length : void 0) != null ? ref : 0;
      }
      return (ref2 = this.keys[i]) != null ? ref2[j] : void 0;
    }

  };

  AutoDrawing = class AutoDrawing extends Drawing {
    /*
    Extended Drawing base class that preprocesses the drawing as follows:
    * Casts all keys to strings, in particular to handle Number data.
    * Optionally removes margins according to `keepMargins` setting.
    * Optionally pads rows to same length according to `keepUneven` setting.
     */
    parse(data) {
      var cell, j, l, len, len1, len2, n, o, row, width;
      //# Turn strings into arrays, and turn numbers (e.g. from XLSX) into strings.
      if (!this.skipStringCast) {
        data = (function() {
          var l, len, results;
          results = [];
          for (l = 0, len = data.length; l < len; l++) {
            row = data[l];
            results.push((function() {
              var len1, n, results1;
              results1 = [];
              for (n = 0, len1 = row.length; n < len1; n++) {
                cell = row[n];
                results1.push(String(cell));
              }
              return results1;
            })());
          }
          return results;
        })();
      }
      if (!this.getSetting('keepMargins')) {
        this.margins = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        //# Top margin
        while (data.length > 0 && allBlank(data[0])) {
          this.margins.top++;
          data.shift();
        }
        //# Bottom margin
        while (data.length > 0 && allBlank(data[data.length - 1])) {
          this.margins.bottom++;
          data.pop();
        }
        if (data.length > 0) {
          //# Left margin
          while (allBlank((function() {
              var len1, n, results;
              results = [];
              for (n = 0, len1 = data.length; n < len1; n++) {
                row = data[n];
                results.push(row[0]);
              }
              return results;
            })())) {
            this.margins.left++;
            for (l = 0, len = data.length; l < len; l++) {
              row = data[l];
              row.shift();
            }
          }
          //# Right margin
          j = (Math.max(0, ...((function() {
            var len1, n, results;
            results = [];
            for (n = 0, len1 = data.length; n < len1; n++) {
              row = data[n];
              results.push(row.length);
            }
            return results;
          })()))) - 1;
          while (j >= 0 && allBlank((function() {
              var len2, o, results;
              results = [];
              for (o = 0, len2 = data.length; o < len2; o++) {
                row = data[o];
                results.push(row[j]);
              }
              return results;
            })())) {
            this.margins.right++;
            for (n = 0, len1 = data.length; n < len1; n++) {
              row = data[n];
              if (j < row.length) {
                row.pop();
              }
            }
            j--;
          }
        }
      }
      if (!this.getSetting('keepUneven')) {
        this.unevenLengths = (function() {
          var len2, o, results;
          results = [];
          for (o = 0, len2 = data.length; o < len2; o++) {
            row = data[o];
            results.push(row.length);
          }
          return results;
        })();
        width = Math.max(0, ...this.unevenLengths);
        for (o = 0, len2 = data.length; o < len2; o++) {
          row = data[o];
          while (row.length < width) {
            row.push('');
          }
        }
      }
      return super.parse(data);
    }

    set(j, i, key) {
      var l, len, oldHeight, ref, results, row;
      oldHeight = this.keys.length;
      super.set(j, i, key);
      //# If we added new rows, make them match row 0's length.
      if (!(oldHeight === this.keys.length || this.getSetting('keepUneven'))) {
        ref = this.keys.slice(oldHeight);
        results = [];
        for (l = 0, len = ref.length; l < len; l++) {
          row = ref[l];
          results.push((function() {
            var results1;
            results1 = [];
            while (row.length < this.keys[0].length) {
              results1.push(row.push(''));
            }
            return results1;
          }).call(this));
        }
        return results;
      }
    }

  };

  ASCIIDrawing = (function() {
    class ASCIIDrawing extends AutoDrawing {
      parse(data) {
        var line;
        return super.parse((function() {
          var l, len, ref, results;
          ref = splitIntoLines(data);
          results = [];
          for (l = 0, len = ref.length; l < len; l++) {
            line = ref[l];
            results.push(graphemeSplitter.splitGraphemes(line));
          }
          return results;
        })());
      }

    };

    ASCIIDrawing.title = "ASCII drawing (one character per tile)";

    return ASCIIDrawing;

  }).call(this);

  DSVDrawing = class DSVDrawing extends AutoDrawing {
    /*
    Abstract base class for all Delimiter-Separator Value (DSV) drawings.
    Each subclass must define `@delimiter` class property.
    */
    parse(data) {
      var ref;
      //# Remove trailing newline / final blank line.
      if (data.slice(-2) === '\r\n') {
        data = data.slice(0, -2);
      } else if ((ref = data.slice(-1)) === '\r' || ref === '\n') {
        data = data.slice(0, -1);
      }
      //# CSV parser.
      return super.parse(require('csv-parse/sync').parse(data, {
        delimiter: this.constructor.delimiter,
        relax_column_count: true
      }));
    }

  };

  SSVDrawing = (function() {
    class SSVDrawing extends DSVDrawing {
      parse(data) {
        //# Coallesce non-newline whitespace into single space
        return super.parse(data.replace(/[ \t\f\v]+/g, ' '));
      }

    };

    SSVDrawing.title = "Space-delimiter drawing (one word per tile: a  b)";

    SSVDrawing.delimiter = ' ';

    return SSVDrawing;

  }).call(this);

  CSVDrawing = (function() {
    class CSVDrawing extends DSVDrawing {};

    CSVDrawing.title = "Comma-separated drawing (spreadsheet export: a,b)";

    CSVDrawing.delimiter = ',';

    return CSVDrawing;

  }).call(this);

  TSVDrawing = (function() {
    class TSVDrawing extends DSVDrawing {};

    TSVDrawing.title = "Tab-separated drawing (spreadsheet export: a<TAB>b)";

    TSVDrawing.delimiter = '\t';

    return TSVDrawing;

  }).call(this);

  PSVDrawing = (function() {
    class PSVDrawing extends DSVDrawing {};

    PSVDrawing.title = "Pipe-separated drawing (spreadsheet export: a|b)";

    PSVDrawing.delimiter = '|';

    return PSVDrawing;

  }).call(this);

  Drawings = class Drawings extends Input {
    parse(datas) {
      var data;
      return this.drawings = (function() {
        var l, len, results;
        results = [];
        for (l = 0, len = datas.length; l < len; l++) {
          data = datas[l];
          results.push(new AutoDrawing(data, {
            settings: this.settings,
            filename: this.filename,
            subname: data.subname
          }));
        }
        return results;
      }).call(this);
    }

    render(settings = this.settings) {
      var drawing, l, len, ref, results;
      ref = this.drawings;
      //# Writes SVG and optionally TeX files.
      //# Returns array of output SVG filenames.
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        drawing = ref[l];
        results.push(drawing.render(settings));
      }
      return results;
    }

  };

  XLSXDrawings = (function() {
    class XLSXDrawings extends Drawings {
      parse(data) {
        var name, rows, sheet, sheetInfo, subname, workbook, xlsx;
        xlsx = require('xlsx');
        workbook = xlsx.read(data, {
          type: 'binary'
        });
        //# .ods imports seem to lack Workbook.Sheets metadata
        if (workbook.Workbook.Sheets == null) {
          console.warn("Warning: Missing sheet metadata, so can't detect hidden sheets");
          workbook.Workbook.Sheets = (function() {
            var l, len, ref, results;
            ref = workbook.SheetNames;
            results = [];
            for (l = 0, len = ref.length; l < len; l++) {
              name = ref[l];
              results.push({name});
            }
            return results;
          })();
        }
        //# https://www.npmjs.com/package/xlsx#common-spreadsheet-format
        return super.parse((function() {
          var l, len, ref, results;
          ref = workbook.Workbook.Sheets;
          results = [];
          for (l = 0, len = ref.length; l < len; l++) {
            sheetInfo = ref[l];
            subname = sheetInfo.name;
            sheet = workbook.Sheets[subname];
            //# 0 = Visible, 1 = Hidden, 2 = Very Hidden
            //# https://sheetjs.gitbooks.io/docs/#sheet-visibility
            if (sheetInfo.Hidden && !this.getSetting('keepHidden')) {
              continue;
            }
            if (subname.length === 31) {
              console.warn(`Warning: Sheet '${subname}' has length exactly 31, which may be caused by Google Sheets export truncation`);
            }
            rows = xlsx.utils.sheet_to_json(sheet, {
              header: 1,
              defval: ''
            });
            rows.subname = subname;
            results.push(rows);
          }
          return results;
        }).call(this));
      }

    };

    XLSXDrawings.encoding = 'binary';

    XLSXDrawings.title = "Spreadsheet drawing(s) (Excel/OpenDocument/Lotus/dBASE)";

    return XLSXDrawings;

  }).call(this);

  DummyInput = class DummyInput extends Input {
    parse() {}

  };

  SVGFile = (function() {
    class SVGFile extends DummyInput {};

    SVGFile.title = "SVG file (convert to PDF/PNG without any tiling)";

    SVGFile.skipRead = true; // svgink/Inkscape will do actual file reading

    return SVGFile;

  }).call(this);

  Tile = class Tile {
    /*
    `Tile` represents a rendered tile, which consists of
    * the input `key` (usually a `String`)
    * coordinates: row `i`, column `j`, and layer `k`;
    * an `SVGSymbol` (`symbol`); and
    * a layout (`xMin`, `yMin`, `xMax`, `yMax`, `width`, `height`).
    We also store `zIndex` and `isEmpty` (from the symbol).
    Note that typically several `Tile`s use the same `SVGSymbol`
    (assuming some re-use of tiles, e.g., repeated keys).
     */
    constructor(opts) {
      var key, ref, value;
      if (opts != null) {
        for (key in opts) {
          value = opts[key];
          this[key] = value;
        }
      }
      if (this.k === 0) {
        if ((ref = this.symbol) != null) {
          if (typeof ref.sizeWarning === "function") {
            ref.sizeWarning();
          }
        }
      }
    }

  };

  //# Do not need to wrap the following elements in <defs>.
  skipDef = new Set(['clipPath', 'defs', 'desc', 'filter', 'linearGradient', 'marker', 'mask', 'metadata', 'pattern', 'radialGradient', 'script', 'style', 'title']);

  deleteFile = function(filename) {
    var err;
    try {
      fs.unlinkSync(filename);
    } catch (error1) {
      err = error1;
      if (err.code === 'ENOENT') {
        return false;
      } else {
        throw err;
      }
    }
    return true;
  };

  Render = class Render extends HasSettings {
    constructor(drawing1, settings1) {
      super();
      this.drawing = drawing1;
      this.settings = settings1;
      if (this.settings == null) {
        this.settings = this.drawing.settings;
      }
      this.backgroundFill = this.getSetting('background');
      this.idVersions = new Map();
      this.mappings = new Mappings(this.getSetting('mappings'));
      this.styles = new Styles(this.getSetting('styles'));
      this.defs = [];
      //# Accumulated rendering, in case add() called before makeDOM():
      this.xMin = this.yMin = this.xMax = this.yMax = null;
      this.layers = {};
    }

    hrefAttr() {
      return hrefAttr(this.settings);
    }

    id(key) { //, noEscape) ->
      var ref, version;
      //# Generate unique ID starting with an escaped version of `key`.
      //# If necessary, appends _v0, _v1, _v2, etc. to make unique.
      key = escapeId(key); //unless noEscape
      version = (ref = this.idVersions.get(key)) != null ? ref : 0;
      this.idVersions.set(key, version + 1);
      if (version) {
        return `${key}_v${version}`;
      } else {
        return key;
      }
    }

    undoId(key) {
      //# Undoes the effect of `@id(key)` by decrementing the version counter.
      key = escapeId(key);
      return this.idVersions.set(key, this.idVersions.get(key) - 1);
    }

    cacheLookup(def) {
      var found;
      /*
      Given `SVGContent` for a `def` (e.g. <symbol>),
      check cache by `value` if it's a string (e.g. filename,
      to avoid loading file again), and by computed SVG string
      (in case multiple paths lead to the same SVG content).
      Returns the cached `SVGContent` if found, or `undefined` if new.
      */
      if (!(typeof def.value === 'string' && ((found = this.cache.get(def.value)) != null))) {
        if (def.value !== def.makeSVG()) {
          if ((found = this.cache.get(def.svg)) == null) {
            this.cache.set(def.svg, def);
          }
        }
        this.cache.set(def.value, def);
      }
      return found;
    }

    def(content) {
      var found;
      content = new SVGContent(getContextString(), content, this.settings);
      if ((found = this.cacheLookup(content)) != null) {
        return found;
      } else {
        content.setId(this.id(content.defaultId('def')));
        this.defs.push(content);
        return content;
      }
    }

    background(fill) {
      if (fill !== void 0) {
        //# Sets current background fill to specified value; `null` to remove.
        //# Returns current background fill.
        this.backgroundFill = fill;
      }
      return this.backgroundFill;
    }

    add(content, prepend) {
      var base1, box, dom, name1, ref;
      if (!(content instanceof SVGContent)) {
        content = new SVGContent(`svgtiler.add content from ${getContextString()}`, content, this.settings);
      }
      dom = content.makeDOM();
      if (content.isEmpty) {
        return;
      }
      if ((box = (ref = content.boundingBox) != null ? ref : content.viewBox) != null) {
        this.expandBox(box);
        this.updateSize();
      }
      if ((base1 = this.layers)[name1 = content.zIndex] == null) {
        base1[name1] = [];
      }
      if (prepend) {
        return this.layers[content.zIndex].unshift(dom);
      } else {
        return this.layers[content.zIndex].push(dom);
      }
    }

    expandBox(box) {
      var x, y;
      if (box[0] != null) {
        if ((this.xMin == null) || box[0] < this.xMin) {
          this.xMin = box[0];
        }
        if (box[2] != null) {
          x = box[0] + box[2];
          if ((this.xMax == null) || x > this.xMax) {
            this.xMax = x;
          }
        }
      }
      if (box[1] != null) {
        if ((this.yMin == null) || box[1] < this.yMin) {
          this.yMin = box[1];
        }
        if (box[3] != null) {
          y = box[1] + box[3];
          if ((this.yMax == null) || y > this.yMax) {
            return this.yMax = y;
          }
        }
      }
    }

    updateSize() {
      if ((this.xMin != null) && (this.xMax != null)) {
        this.width = this.xMax - this.xMin;
      } else {
        this.width = 0;
      }
      if ((this.yMin != null) && (this.yMax != null)) {
        return this.height = this.yMax - this.yMin;
      } else {
        return this.height = 0;
      }
    }

    forEach(callback) {
      return runWithContext(new Context(this), () => {
        var i, j, l, len, ref, results, row;
        ref = this.drawing.keys;
        results = [];
        for (i = l = 0, len = ref.length; l < len; i = ++l) {
          row = ref[i];
          results.push((function() {
            var n, ref1, results1;
            results1 = [];
            for (j = n = 0, ref1 = row.length; (0 <= ref1 ? n < ref1 : n > ref1); j = 0 <= ref1 ? ++n : --n) {
              currentContext.move(j, i);
              results1.push(callback.call(currentContext, currentContext));
            }
            return results1;
          })());
        }
        return results;
      });
    }

    context(i, j) {
      return new Context(this, i, j);
    }

    makeDOM() {
      return runWithRender(this, () => {
        return runWithContext(new Context(this), () => {
          /*
          Main rendering engine, returning an xmldom object for the whole document.
          Also saves the table of `Tile`s (symbols with layout geometry) in `@tiles`,
          and bounding box in `@xMin`, `@xMax`, `@yMin`, `@yMax`,
          `@width`, and `@height`.
          */
          var base1, colWidths, container, def, defDoms, defsWrapper, doc, dom, dx, dy, error, errored, findGlobalDefs, firstSymbol, found, globalIdMap, i, id, idSet, inlineImages, j, k, key, l, layer, layerOrder, len, len1, len2, len3, len4, len5, len6, len7, len8, len9, missing, n, name1, node, o, p, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, row, row2, rowHeight, s, scaleX, scaleY, style, styleTag, symbol, symbols, t, tile, tiles, u, use, useDefs, usedIds, v, w, x, y;
          doc = domImplementation.createDocument(SVGNS, 'svg');
          this.dom = doc.documentElement;
          if (!this.getSetting('useHref')) {
            this.dom.setAttribute('xmlns:xlink', XLINKNS);
          }
          this.dom.setAttribute('version', '1.1');
          //@dom.appendChild defs = doc.createElementNS SVGNS, 'defs'

          //# Preprocess callbacks, which may change anything about the Render job
          this.mappings.doPreprocess(this);
          ref = this.styles;
          //# <style> tags for CSS
          for (l = 0, len = ref.length; l < len; l++) {
            style = ref[l];
            this.dom.appendChild(styleTag = doc.createElementNS(SVGNS, 'style'));
            styleTag.textContent = style.css;
          }
          //# --use-defs wraps all <symbol>s inside <def>s
          useDefs = this.getSetting('useDefs');
          defsWrapper = useDefs ? doc.createElementNS(SVGNS, 'defs') : void 0;
          container = useDefs ? defsWrapper : this.dom;
          //# Render all tiles in the drawing.
          missing = new Set();
          errored = new Set();
          this.cache = new Map();
          this.tiles = (function() {
            var len1, n, ref1, results;
            ref1 = this.drawing.keys;
            results = [];
            for (i = n = 0, len1 = ref1.length; n < len1; i = ++n) {
              row = ref1[i];
              results.push((function() {
                var len2, o, results1;
                results1 = [];
                for (j = o = 0, len2 = row.length; o < len2; j = ++o) {
                  key = row[j];
                  currentContext.move(j, i);
                  try {
                    symbols = this.mappings.lookup(key, currentContext);
                  } catch (error1) {
                    error = error1;
                    console.warn(`Error while evaluating mapping for key '${key}':`);
                    console.error(error);
                    errored.add(key);
                    symbols = errorSymbol;
                  }
                  if (!((symbols != null) && symbols.length !== 0)) {
                    missing.add(key);
                    symbols = unrecognizedSymbol;
                  }
                  if (!Array.isArray(symbols)) {
                    symbols = [symbols];
                  }
                  results1.push((function() {
                    var len3, p, results2;
                    results2 = [];
                    for (k = p = 0, len3 = symbols.length; p < len3; k = ++p) {
                      symbol = symbols[k];
                      //# Check cache for this symbol
                      if ((found = this.cacheLookup(symbol)) != null) {
                        symbol = found;
                      } else {
                        if (symbol.id == null) {
                          //# Set id before generating DOM (needed for `isEmpty`)
                          //# to make `id` the first attribute.
                          symbol.setId(id = this.id(key)); // unrecognizedSymbol has id
                        }
                        symbol.makeDOM();
                        if (symbol.isEmpty) {
                          this.undoId(key);
                          symbol.setId('_empty');
                        } else {
                          //# Include new non-empty <symbol> in SVG
                          container.appendChild(symbol.useDOM());
                        }
                      }
                      results2.push(new Tile({
                        i,
                        j,
                        k,
                        key,
                        symbol,
                        isEmpty: symbol.isEmpty,
                        zIndex: symbol.zIndex
                      }));
                    }
                    return results2;
                  }).call(this));
                }
                return results1;
              }).call(this));
            }
            return results;
          }).call(this);
          currentContext = null;
          missing = (function() {
            var results;
            results = [];
            for (key of missing) {
              results.push(`'${key}'`);
            }
            return results;
          })();
          errored = (function() {
            var results;
            results = [];
            for (key of errored) {
              results.push(`'${key}'`);
            }
            return results;
          })();
          if (missing.length) {
            console.warn("Failed to recognize tiles:", missing.join(', '));
          }
          if (errored.length) {
            console.warn("Errors during tiles:", errored.join(', '));
          }
          //# Lay out the tiles in the drawing via SVG <use>.
          y = 0;
          colWidths = {};
          ref1 = this.tiles;
          for (i = n = 0, len1 = ref1.length; n < len1; i = ++n) {
            row = ref1[i];
            rowHeight = 0;
            for (o = 0, len2 = row.length; o < len2; o++) {
              tiles = row[o];
              for (p = 0, len3 = tiles.length; p < len3; p++) {
                tile = tiles[p];
                if (!tile.symbol.autoHeight && tile.symbol.height > rowHeight) {
                  rowHeight = tile.symbol.height;
                }
              }
            }
            x = 0;
            for (j = q = 0, len4 = row.length; q < len4; j = ++q) {
              tiles = row[j];
              for (k = s = 0, len5 = tiles.length; s < len5; k = ++s) {
                tile = tiles[k];
                ({symbol} = tile);
                tile.xMin = x;
                tile.yMin = y;
                if (symbol == null) {
                  tile.width = tile.height = 0;
                  tile.xMax = x;
                  tile.yMax = y;
                  continue;
                }
                scaleX = scaleY = 1;
                if (symbol.autoWidth && symbol.width > 0) {
                  if (k === 0) {
                    if (colWidths[j] == null) {
                      colWidths[j] = Math.max(0, ...((function() {
                        var len6, ref2, ref3, ref4, results, t;
                        ref2 = this.tiles;
                        results = [];
                        for (t = 0, len6 = ref2.length; t < len6; t++) {
                          row2 = ref2[t];
                          if ((((ref3 = row2[j]) != null ? (ref4 = ref3[0]) != null ? ref4.symbol : void 0 : void 0) != null) && !row2[j][0].symbol.autoWidth) {
                            results.push(row2[j][0].symbol.width);
                          }
                        }
                        return results;
                      }).call(this)));
                    }
                    scaleX = colWidths[j] / symbol.width;
                  } else {
                    scaleX = tiles[0].width / symbol.width;
                  }
                  if (!symbol.autoHeight) {
                    scaleY = scaleX;
                  }
                }
                if (symbol.autoHeight && symbol.height > 0) {
                  if (k === 0) {
                    scaleY = rowHeight / symbol.height;
                  } else {
                    scaleX = tiles[0].height / symbol.height;
                  }
                  if (!symbol.autoWidth) {
                    scaleX = scaleY;
                  }
                }
                tile.width = symbol.width * scaleX;
                tile.height = symbol.height * scaleY;
                tile.xMax = x + tile.width;
                tile.yMax = y + tile.height;
                if (!tile.isEmpty) {
                  if ((base1 = this.layers)[name1 = tile.zIndex] == null) {
                    base1[name1] = [];
                  }
                  this.layers[tile.zIndex].push(use = doc.createElementNS(SVGNS, 'use'));
                  use.setAttribute(this.hrefAttr(), '#' + symbol.id);
                  use.setAttribute('x', x);
                  use.setAttribute('y', y);
                  //# Symbols generally set their own width and height,
                  //# so only need to set these on <use> when they are 'auto'.
                  //# SVG's scaling of tile is relative to viewBox (including possible
                  //# `zeroSizeReplacement`), so use viewBox to define width and
                  //# height attributes:
                  if (symbol.autoWidth) {
                    use.setAttribute('width', ((ref2 = (ref3 = symbol.viewBox) != null ? ref3[2] : void 0) != null ? ref2 : symbol.width) * scaleX);
                  }
                  if (symbol.autoHeight) {
                    use.setAttribute('height', ((ref4 = (ref5 = symbol.viewBox) != null ? ref5[3] : void 0) != null ? ref4 : symbol.height) * scaleY);
                  }
                  if (this.settings.useData) {
                    use.setAttribute('data-key', tile.key);
                    use.setAttribute('data-i', i);
                    use.setAttribute('data-j', j);
                    if (tiles.length > 1) {
                      use.setAttribute('data-k', k);
                    }
                  }
                }
                if (symbol.boundingBox != null) {
                  dx = (symbol.boundingBox[0] - symbol.viewBox[0]) * scaleX;
                  dy = (symbol.boundingBox[1] - symbol.viewBox[1]) * scaleY;
                  this.expandBox([symbol.boundingBox[0] != null ? x + dx : void 0, symbol.boundingBox[1] != null ? y + dy : void 0, symbol.boundingBox[2] != null ? symbol.boundingBox[2] * scaleX : void 0, symbol.boundingBox[3] != null ? symbol.boundingBox[3] * scaleY : void 0]);
                } else {
                  this.expandBox([tile.xMin, tile.yMin, tile.width, tile.height]);
                }
              }
              x = tiles[0].xMax;
            }
            y += rowHeight;
          }
          //# Postprocess callbacks, which may use (and update) @width/@height
          if (this.xMin == null) {
            this.xMin = 0;
          }
          if (this.yMin == null) {
            this.yMin = 0;
          }
          if (this.xMax == null) {
            this.xMax = 0;
          }
          if (this.yMax == null) {
            this.yMax = 0;
          }
          this.updateSize();
          this.mappings.doPostprocess(this);
          //# Background fill, now that size has settled
          if ((this.backgroundFill != null ? this.backgroundFill : this.backgroundFill = this.getSetting('background')) != null) {
            this.add(new SVGContent("background", `<rect z-index="-Infinity" x="${this.xMin}" y="${this.yMin}" width="${this.width}" height="${this.height}" fill="${this.backgroundFill}"/>`, this.settings), true); // prepend
          }
          
          //# Check for global <defs> used by the symbols so far.
          usedIds = new Set();
          globalIdMap = new Map();
          findGlobalDefs = (root) => {
            var attr, def, desireId, len6, newId, node, ref6, ref7, results, t;
            ref6 = findRefs(root);
            results = [];
            for (t = 0, len6 = ref6.length; t < len6; t++) {
              ({id, node, attr} = ref6[t]);
              desireId = unglobalId(id);
              if (id === desireId) { // local id
                results.push(usedIds.add(id)); // global id
              } else {
                if ((newId = globalIdMap.get(id)) == null) {
                  if ((def = globalDefs.get(id)) == null) {
                    throw new SVGTilerError(`Referenced global ID '${id}' in node ${node} not found`);
                  }
                  if ((found = this.cacheLookup(def)) != null) {
                    newId = (ref7 = found.idOverride) != null ? ref7 : found.id;
                  } else {
                    globalIdMap.set(id, newId = this.id(desireId));
                    usedIds.add(newId);
                    //# Don't call `def.setId` which breaks `id` for global def
                    //# potentially used in a future Render; instead, override id
                    //# just for this DOM.
                    def.idOverride = newId;
                    this.defs.push(def);
                  } // first use
                }
                results.push(node.setAttribute(attr, node.getAttribute(attr).replace(`#${id}`, `#${newId}`)));
              }
            }
            return results;
          };
          //# Search <symbol>s created for tiles
          findGlobalDefs(container);
          ref6 = this.layers;
          //# Search layer content, including from `svgtiler.add`
          for (key in ref6) {
            layer = ref6[key];
            for (t = 0, len6 = layer.length; t < len6; t++) {
              node = layer[t];
              findGlobalDefs(node);
            }
          }
          //# Render all <defs> so far and check for additional <defs> used by them.
          //# `for def in @defs` but allowing @defs to change in length
          //# from additional global <defs> encountered along the way.
          i = 0;
          defDoms = (function() {
            var results;
            results = [];
            while (i < this.defs.length) {
              def = this.defs[i++];
              dom = def.useDOM();
              //# Look for more global <defs> used by this def.
              findGlobalDefs(dom);
              results.push({def, dom});
            }
            return results;
          }).call(this);
          //# Add <defs> to DOM if they're used or forced.
          firstSymbol = container.firstChild;
          for (u = 0, len7 = defDoms.length; u < len7; u++) {
            ({def, dom} = defDoms[u]);
            if (!(def.isForced || usedIds.has(dom.getAttribute('id')))) {
              //# Omit unused <defs> unless forced.
              continue;
            }
            //# Wrap in <defs> if needed.
            if (!useDefs && skipDef.has(dom.tagName)) {
              this.dom.insertBefore(dom, firstSymbol);
            } else {
              if (defsWrapper == null) {
                defsWrapper = doc.createElementNS(SVGNS, 'defs');
              }
              if (useDefs) {
                defsWrapper.insertBefore(dom, firstSymbol);
              } else {
                defsWrapper.appendChild(dom);
              }
            }
          }
          if (defsWrapper != null) {
            // Note: If @dom.firstChild is null, insertBefore degenerates to append
            this.dom.insertBefore(defsWrapper, this.dom.firstChild);
          }
          //# Factor out duplicate inline <image>s into separate <symbol>s.
          inlineImages = new Map();
          domRecurse(this.dom, (node) => {
            var attr, attributes, filename, height, href, len8, ref7, ref8, v, width;
            if (node.nodeName !== 'image') {
              return true;
            }
            ({href} = getHref(node));
            if (!(href != null ? href.startsWith('data:') : void 0)) {
              return true;
            }
            // data-filename gets set to the original filename when inlining,
            // which we use for key labels so isn't needed as an exposed attribute.
            // Ditto for width and height of image.
            filename = (ref7 = node.getAttribute('data-filename')) != null ? ref7 : '';
            node.removeAttribute('data-filename');
            width = node.getAttribute('data-width');
            node.removeAttribute('data-width');
            height = node.getAttribute('data-height');
            node.removeAttribute('data-height');
            // Transfer x/y/width/height to <use> element, for more re-usability.
            node.parentNode.replaceChild((use = doc.createElementNS(SVGNS, 'use')), node);
            ref8 = ['x', 'y', 'width', 'height'];
            for (v = 0, len8 = ref8.length; v < len8; v++) {
              attr = ref8[v];
              if (node.hasAttribute(attr)) {
                use.setAttribute(attr, node.getAttribute(attr));
              }
              node.removeAttribute(attr);
            }
            // Memoize versions
            attributes = (function() {
              var len9, ref9, results, w;
              ref9 = node.attributes;
              results = [];
              for (w = 0, len9 = ref9.length; w < len9; w++) {
                attr = ref9[w];
                results.push(`${attr.name}=${attr.value}`);
              }
              return results;
            })();
            attributes.sort();
            attributes = attributes.join(' ');
            if ((id = inlineImages.get(attributes)) == null) {
              inlineImages.set(attributes, id = this.id(filename));
              container.appendChild(symbol = doc.createElementNS(SVGNS, 'symbol'));
              symbol.setAttribute('id', id);
              // If we don't have width/height set from data-width/height fields,
              // we take the first used width/height as the defining height.
              node.setAttribute('width', width || use.getAttribute('width'));
              node.setAttribute('height', height || use.getAttribute('height'));
              symbol.setAttribute('viewBox', `0 0 ${width} ${height}`);
              symbol.appendChild(node);
            }
            use.setAttribute(this.hrefAttr(), '#' + id);
            return false;
          });
          //# Sort <use>s by layer
          layerOrder = ((function() {
            var results;
            results = [];
            for (layer in this.layers) {
              results.push(layer);
            }
            return results;
          }).call(this)).sort(function(x, y) {
            return x - y;
          });
          for (v = 0, len8 = layerOrder.length; v < len8; v++) {
            layer = layerOrder[v];
            ref7 = this.layers[layer];
            for (w = 0, len9 = ref7.length; w < len9; w++) {
              node = ref7[w];
              this.dom.appendChild(node);
            }
          }
          this.dom.setAttribute('viewBox', `${this.xMin} ${this.yMin} ${this.width} ${this.height}`);
          this.dom.setAttribute('width', this.width);
          this.dom.setAttribute('height', this.height);
          //@dom.setAttribute 'preserveAspectRatio', 'xMinYMin meet'

          //# Warn about duplicate ids
          idSet = new Set();
          domRecurse(this.dom, (node) => {
            if (node.attributes == null) {
              return;
            }
            if ((id = node.getAttribute('id'))) {
              if (idSet.has(id)) {
                console.warn(`Duplicate id in output SVG: ${id}`);
              } else {
                idSet.add(id);
              }
            }
            return true;
          });
          return this.dom;
        });
      });
    }

    makeSVG() {
      var out;
      out = new XMLSerializer().serializeToString(this.makeDOM());
      //# Parsing xlink:href in user's SVG fragments, and then serializing,
      //# can lead to these null namespace definitions.  Remove.
      out = out.replace(/\sxmlns:xlink=""/g, '');
      if (prettyXML != null) {
        out = prettyXML(out, {
          newline: '\n' //# force consistent line endings, not require('os').EOL
        });
      }
      return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
` + out;
    }

    makeTeX(filename, relativeDir) {
      var align, anchor, basename, child, content, i, j, k, l, len, len1, len2, len3, lines, n, o, p, ref, ref1, ref2, ref3, row, text, tile, tiles, tx, ty, vertical, wrap, xMin, yMin;
      if (this.tiles == null) {
        this.makeDOM();
      }
      filename = path.parse(filename);
      basename = filename.base.slice(0, -filename.ext.length);
      if (relativeDir) {
        relativeDir += '/';
        //# TeX uses forward slashes for path separators
        if (process.platform === 'win32') {
          relativeDir = relativeDir.replace(/\\/g, '/');
        }
      }
      //# LaTeX based loosely on Inkscape's PDF/EPS/PS + LaTeX output extension.
      //# See http://tug.ctan.org/tex-archive/info/svg-inkscape/
      lines = [
        `%% Creator: svgtiler, https://github.com/edemaine/svgtiler
%% This LaTeX file includes and overlays text on top of companion file
%% ${basename}.pdf/.png
%%
%% Instead of \\includegraphics, include this figure via
%%   \\input{${filename.base}}
%% You can scale the image by first defining \\svg{width,height,scale}:
%%   \\def\\svgwidth{\\linewidth} % full width
%% or
%%   \\def\\svgheight{5in}
%% or
%%   \\def\\svgscale{0.5} % 50%
%% (If multiple are specified, the first in the list above takes priority.)
%%
%% If this file resides in another directory from the root .tex file,
%% you need to help it find its auxiliary .pdf/.png file via one of the
%% following options (any one will do):
%%   1. \\usepackage{currfile} so that this file can find its own directory.
%%   2. \\usepackage{import} and \\import{path/to/file/}{${filename.base}}
%%      instead of \\import{${filename.base}}
%%   3. \\graphicspath{{path/to/file/}} % note extra braces and trailing slash
%%
\\begingroup
  \\providecommand\\color[2][]{%
    \\errmessage{You should load package 'color.sty' to render color in svgtiler text.}%
    \\renewcommand\\color[2][]{}%
  }%
  \\ifx\\currfiledir\\undefined
    \\def\\currfiledir{}%
  \\fi
  \\ifx\\svgwidth\\undefined
    \\ifx\\svgheight\\undefined
      \\unitlength=0.75bp\\relax % 1px (SVG unit) = 0.75bp (SVG pts)
      \\ifx\\svgscale\\undefined\\else
        \\ifx\\real\\undefined % in case calc.sty not loaded
          \\unitlength=\\svgscale \\unitlength
        \\else
          \\setlength{\\unitlength}{\\unitlength * \\real{\\svgscale}}%
        \\fi
      \\fi
    \\else
      \\unitlength=\\svgheight
      \\unitlength=${1 / this.height}\\unitlength % divide by image height
    \\fi
  \\else
    \\unitlength=\\svgwidth
    \\unitlength=${1 / this.width}\\unitlength % divide by image width
  \\fi
  \\def\\clap#1{\\hbox to 0pt{\\hss#1\\hss}}%
  \\begin{picture}(${this.width},${this.height})%
    \\put(0,0){\\includegraphics[width=${this.width}\\unitlength]{\\currfiledir ${relativeDir != null ? relativeDir : ''}${basename}}}%`
      ];
      ref = this.tiles;
      for (i = l = 0, len = ref.length; l < len; i = ++l) {
        row = ref[i];
        for (j = n = 0, len1 = row.length; n < len1; j = ++n) {
          tiles = row[j];
          for (k = o = 0, len2 = tiles.length; o < len2; k = ++o) {
            tile = tiles[k];
            ({xMin, yMin} = tile);
            if (tile.symbol.text == null) {
              continue; // e.g. unrecognizedSymbol
            }
            ref1 = tile.symbol.text;
            for (p = 0, len3 = ref1.length; p < len3; p++) {
              text = ref1[p];
              tx = (ref2 = parseNum(text.getAttribute('x'))) != null ? ref2 : 0;
              ty = (ref3 = parseNum(text.getAttribute('y'))) != null ? ref3 : 0;
              content = ((function() {
                var len4, q, ref4, results;
                ref4 = text.childNodes;
                results = [];
                for (q = 0, len4 = ref4.length; q < len4; q++) {
                  child = ref4[q];
                  if (child.nodeType === child.TEXT_NODE) {
                    results.push(child.data);
                  }
                }
                return results;
              })()).join('');
              anchor = attributeOrStyle(text, 'text-anchor');
              if (/^\s*middle\b/.test(anchor)) {
                align = 'c';
              } else if (/^\s*end\b/.test(anchor)) {
                align = 'r'; //if /^\s*start\b/.test anchor  # default
              } else {
                align = 'l';
              }
              vertical = attributeOrStyle(text, 'alignment-baseline');
              if (/^\s*(middle|central)\b/.test(vertical)) {
                align += '';
              } else if (/^\s*(hanging|(text-)?top)\b/.test(vertical)) {
                align += 't'; //if /^\s*(baseline|auto|(text-)?bottom)\b/.test vertical  # default
              } else {
                align += 'b';
              }
              wrap = `\\makebox(0,0)[${align}]{`;
              // "@height -" is to flip between y down (SVG) and y up (picture)
              lines.push(`    \\put(${xMin + tx},${this.height - (yMin + ty)}){\\color{${attributeOrStyle(text, 'fill') || 'black'}}${wrap}${content}${wrap && '}'}}%`);
            }
          }
        }
      }
      lines.push(`  \\end{picture}%
\\endgroup`, ''); // trailing newline
      return lines.join('\n');
    }

    writeSVG(filename) {
      //# Generates SVG and writes to filename.
      //# Default filename is the input filename with extension replaced by .svg.
      //# Returns generated .svg filename (even if it didn't changed).
      if (filename == null) {
        filename = this.drawing.generateFilename('.svg');
      }
      if (this.getSetting('clean')) {
        console.log('->', filename, deleteFile(filename) ? '(ALREADY CLEANED)' : '(CLEANED)');
      } else if (!this.shouldGenerate(filename, this.mappings, this.styles)) {
        console.log('->', filename, '(SKIPPED)');
      } else if (maybeWrite(filename, this.makeSVG())) {
        console.log('->', filename);
      } else {
        console.log('->', filename, '(UNCHANGED)');
      }
      return filename;
    }

    writeTeX(filename, relativeDir) {
      var outputDir, ref, ref1;
      /*
      Default filename is the input filename with extension replaced by .svg_tex
      (analogous to .pdf_tex from Inkscape's --export-latex feature, but noting
      that the text is extracted from the SVG not the PDF, and that this file
      works with both .pdf and .png auxiliary files).
      */
      if (filename == null) {
        filename = this.drawing.generateFilename('.svg_tex');
      }
      if ((relativeDir == null) && ((outputDir = (ref = (ref1 = this.getOutputDir('.pdf')) != null ? ref1 : this.getOutputDir('.png')) != null ? ref : this.getOutputDir('.svg')) != null)) {
        relativeDir = path.relative(path.parse(filename).dir, outputDir);
      }
      if (this.getSetting('clean')) {
        console.log(' &', filename, deleteFile(filename) ? '(ALREADY CLEANED)' : '(CLEANED)');
      } else if (!this.shouldGenerate(filename, this.mappings)) {
        console.log(' &', filename, '(SKIPPED)');
      } else if (maybeWrite(filename, this.makeTeX(filename, relativeDir))) {
        console.log(' &', filename);
      } else {
        console.log(' &', filename, '(UNCHANGED)');
      }
      return filename;
    }

    shouldGenerate(filename, ...depGroups) {
      var dep, depGroup, l, len, len1, modified, n;
      if (this.getSetting('force')) {
        return true;
      }
      try {
        modified = (fs.statSync(filename)).mtimeMs;
      } catch (error1) {}
      if (modified == null) {
        //# If file doesn't exist or can't be stat, need to generate it.
        return true;
      }
      if ((metadata.modified != null) && metadata.modified > modified) {
        //# If SVG Tiler is newer than file, need to generate it.
        return true;
      }
      if ((this.drawing.modified != null) && this.drawing.modified > modified) {
        //# If drawing is newer than file, need to generate it.
        return true;
      }
//# If dependency is newer than file, need to generate it.
      for (l = 0, len = depGroups.length; l < len; l++) {
        depGroup = depGroups[l];
//# `depGroup` may be a `Mappings` or `Styles` object
//# (which both implement array interface).
        for (n = 0, len1 = depGroup.length; n < len1; n++) {
          dep = depGroup[n];
          if ((dep.modified != null) && dep.modified > modified) {
            return true;
          }
        }
      }
      return false;
    }

  };

  globalIdCount = 0;

  globalId = function(baseId = 'id') {
    if (currentRender != null) {
      return currentRender.id(baseId);
    } else {
      return `_global${globalIdCount++}_${escapeId(baseId)}`;
    }
  };

  unglobalId = function(id) {
    return id.replace(/^_global\d+_/, '');
  };

  globalDefs = new Map();

  globalDef = function(content) {
    if (currentRender != null) {
      return currentRender.def(content);
    } else {
      content = new SVGContent(getContextString(), content, getSettings());
      content.setId(globalId(content.defaultId('def')));
      content.isStatic = true; // global def may get re-used in multiple renders
      globalDefs.set(content.id, content);
      return content;
    }
  };

  globalBackground = function(fill) {
    //# Sets current/default background fill to specified value; `null` to remove.
    //# Returns current background fill.
    if (currentRender != null) {
      return currentRender.background(fill);
    } else {
      //else if currentMapping?
      //  preprocess (render) -> render.background fill
      throw new SVGTilerError("svgtiler.background called outside of render context");
    }
  };

  globalAdd = function(content, ...opts) {
    if (currentRender != null) {
      return currentRender.add(content, ...opts);
    } else {
      throw new SVGTilerError("svgtiler.add called outside of render context");
    }
  };

  Context = class Context {
    constructor(render1, i, j) {
      this.render = render1;
      this.drawing = this.render.drawing;
      if ((i != null) && (j != null)) {
        //# Use @drawing to access these old properties:
        //@keys = @drawing.keys
        //@filename = @drawing.filename
        //@subname = @drawing.subname
        this.move(j, i);
      }
    }

    move(j1, i1) {
      var ref;
      this.j = j1;
      this.i = i1;
      //# Change location in-place
      return this.key = (ref = this.drawing.keys[this.i]) != null ? ref[this.j] : void 0;
    }

    set(key) {
      //# Change key for this location
      return this.drawing.set(this.j, this.i, key);
    }

    at(j, i) {
      var ref, ref1;
      //# Negative numbers wrap around
      if (i < 0) {
        i += this.drawing.keys.length;
      }
      if (j < 0) {
        j += (ref = (ref1 = this.drawing.keys[i]) != null ? ref1.length : void 0) != null ? ref : 0;
      }
      return new Context(this.render, i, j);
    }

    neighbor(dj, di) {
      return new Context(this.render, this.i + di, this.j + dj);
    }

    includes(...args) {
      return (this.key != null) && this.key.includes(...args);
    }

    match(...args) {
      return (this.key != null) && this.key.match(...args);
    }

    startsWith(...args) {
      return (this.key != null) && this.key.startsWith(...args);
    }

    endsWith(...args) {
      return (this.key != null) && this.key.endsWith(...args);
    }

    row(di = 0) {
      var i, j, key, l, len, ref, ref1, results;
      i = this.i + di;
      ref1 = (ref = this.drawing.keys[i]) != null ? ref : [];
      results = [];
      for (j = l = 0, len = ref1.length; l < len; j = ++l) {
        key = ref1[j];
        results.push(new Context(this.render, i, j));
      }
      return results;
    }

    column(dj = 0) {
      var i, j, l, len, ref, results, row;
      j = this.j + dj;
      ref = this.drawing.keys;
      results = [];
      for (i = l = 0, len = ref.length; l < len; i = ++l) {
        row = ref[i];
        results.push(new Context(this.render, i, j));
      }
      return results;
    }

  };

  Object.defineProperties(Context.prototype, {
    filename: {
      get: function() {
        return this.drawing.filename;
      }
    },
    subname: {
      get: function() {
        return this.drawing.subname;
      }
    }
  });

  extensionMap = {
    // Mappings
    '.txt': ASCIIMapping,
    '.js': JSMapping,
    '.jsx': JSMapping,
    '.coffee': CoffeeMapping,
    '.cjsx': CoffeeMapping,
    // Drawings
    '.asc': ASCIIDrawing,
    '.ssv': SSVDrawing,
    '.csv': CSVDrawing,
    '.tsv': TSVDrawing,
    '.psv': PSVDrawing,
    //# Parsable by xlsx package:
    '.xlsx': XLSXDrawings, //# Excel 2007+ XML Format
    '.xlsm': XLSXDrawings, //# Excel 2007+ Macro XML Format
    '.xlsb': XLSXDrawings, //# Excel 2007+ Binary Format
    '.xls': XLSXDrawings, //# Excel 2.0 or 2003-2004 (SpreadsheetML)
    '.ods': XLSXDrawings, //# OpenDocument Spreadsheet
    '.fods': XLSXDrawings, //# Flat OpenDocument Spreadsheet
    '.dif': XLSXDrawings, //# Data Interchange Format (DIF)
    '.prn': XLSXDrawings, //# Lotus Formatted Text
    '.dbf': XLSXDrawings, //# dBASE II/III/IV / Visual FoxPro
    // Styles
    '.css': CSSStyle,
    '.styl': StylusStyle,
    // Other
    '.svg': SVGFile,
    '.args': ParsedArgs
  };

  //filenameMap =
  //  'maketile': ParsedArgs
  renderDOM = function(elts, settings) {
    var dom, drawing, elt, eltSettings, err, filename, key, ref, results, value;
    if (typeof elts === 'string') {
      elts = document.querySelectorAll(elts);
    } else if (elts instanceof HTMLElement) {
      elts = [elts];
    }
    results = [];
    for (elt of elts) {
      //# Default to href attribute which works better in DOM.
      eltSettings = {
        ...defaultSettings,
        useHref: true,
        ...settings
      };
      ref = elt.dataset;
      //# Override settings via data-* attributes.
      for (key in ref) {
        value = ref[key];
        if (!eltSettings.hasOwnProperty(key)) {
          continue;
        }
        if (typeof eltSettings[key] === 'boolean') {
          switch (value = setting(key)) {
            //when 'true', 'on', 'yes'
            //  eltSettings[key] = true
            case 'false':
            case 'off':
            case 'no': //, ''
              eltSettings[key] = false;
              break;
            default:
              eltSettings[key] = Boolean(value);
          }
        } else {
          eltSettings[key] = value;
        }
      }
      try {
        elt.style.whiteSpace = 'pre';
        filename = eltSettings.filename;
        drawing = Input.recognize(filename, elt.innerText, eltSettings);
        if (drawing instanceof Drawing) {
          dom = drawing.renderDOM();
          if (eltSettings.keepParent) {
            elt.innerHTML = '';
            elt.appendChild(dom);
          } else {
            elt.replaceWith(dom);
            if (eltSettings.keepClass) {
              dom.setAttribute('class', elt.className);
            }
          }
        } else {
          console.warn(`Parsed element with filename '${filename}' into ${drawing.constructor.name} instead of Drawing:`, elt);
          dom = null;
        }
        results.push({
          input: elt,
          output: dom,
          drawing: drawing,
          filename: filename
        });
      } catch (error1) {
        err = error1;
        console.error('svgtiler.renderDOM failed to render element:', elt);
        results.push(console.error(err));
      }
    }
    return results;
  };

  help = function() {
    var extension, klass;
    console.log(`svgtiler ${metadata.version}
Usage: ${process.argv[1]} (...options and filenames...)
Documentation: https://github.com/edemaine/svgtiler

Optional arguments:
  -h / --help           Show this help message and exit.
  -p / --pdf            Convert output SVG files to PDF via Inkscape
  -P / --png            Convert output SVG files to PNG via Inkscape
  -t / --tex            Move <text> from SVG to accompanying LaTeX file.svg_tex
  -f / --force          Force SVG/TeX/PDF/PNG creation even if deps older
  -v / --verbose        Log behind-the-scenes action to aid debugging
  -o DIR / --output DIR Write all output files to directory DIR
  -O STEM / --output-stem STEM  Write next output to STEM.{svg,svg_tex,pdf,png}
                                (STEM can use * to refer to input stem)
  --os DIR / --output-svg DIR   Write all .svg files to directory DIR
  --op DIR / --output-pdf DIR   Write all .pdf files to directory DIR
  --oP DIR / --output-png DIR   Write all .png files to directory DIR
  --ot DIR / --output-tex DIR   Write all .svg_tex files to directory DIR
  --clean               Delete SVG/TeX/PDF/PNG files that would be generated
  -i PATH / --inkscape PATH     Specify PATH to Inkscape binary
  -j N / --jobs N       Run up to N Inkscape jobs in parallel
  --maketile GLOB       Custom Maketile file or glob pattern
  -s KEY=VALUE / --share KEY=VALUE  Set share.KEY to VALUE (undefined if no =)
  -m / --margin         Don't delete blank extreme rows/columns
  --uneven              Don't make all rows have same length by padding with ''
  --hidden              Process hidden sheets within spreadsheet files
  --bg BG / --background BG  Set background fill color to BG
  --tw TILE_WIDTH / --tile-width TILE_WIDTH
                        Force all tiles to have specified width
  --th TILE_HEIGHT / --tile-height TILE_HEIGHT
                        Force all tiles to have specified height
  --no-inline           Don't inline <image>s into output SVG
  --no-overflow         Don't default <symbol> overflow to "visible"
  --no-sanitize         Don't sanitize PDF output by blanking out /CreationDate
  --use-href            Use href attribute instead of xlink:href attribute
  --use-defs            Wrap <symbol>s in <def>s (for Inkscape bug with nesting)
  --use-data            Add data-{key,i,j,k} attributes to <use> elements
  (                     Remember settings, mappings, styles, and share values
  )                     Restore last remembered settings/mappings/styles/share

Filename arguments:  (mappings and styles before relevant drawings!)
`);
    for (extension in extensionMap) {
      klass = extensionMap[extension];
      if (extension.length < 10) {
        extension += ' '.repeat(10 - extension.length);
      }
      console.log(`  *${extension}  ${klass.title}`);
      if (klass.help != null) {
        console.log(`               ${klass.help}`);
      }
    }
    console.log(`
TILE specifiers:  (omit the quotes in anything except .js and .coffee files)

  'filename.svg':   load SVG from specified file
  'filename.png':   include PNG image from specified file
  'filename.jpg':   include JPEG image from specified file
  '<svg>...</svg>' or '<symbol>...</symbol>': raw SVG string
  <svg>...</svg> or <symbol>...</symbol>: SVG in JSX notation
  -> ...@key...:    function computing SVG, with \`this\` bound to Context with
                    \`key\` (tile name), \`i\` and \`j\` (y and x coordinates),
                    \`filename\` (drawing filename), \`subname\` (subsheet name),
                    and supporting \`neighbor\`/\`includes\`/\`row\`/\`column\` methods`);
    //object with one or more attributes
    return process.exit();
  };

  processor = null;

  convert = function(filenames, settings) {
    var filename, l, len, results, svgink;
    if (!settings.formats.length) {
      return;
    }
    if (processor == null) {
      svgink = require('svgink');
      settings = {...svgink.defaultSettings, ...settings};
      processor = new svgink.SVGProcessor(settings).on('converted', (data) => {
        console.log(`   ${data.input} -> ${data.output}` + (data.skip ? ' (SKIPPED)' : ''));
        if (data.stdout) {
          console.log(data.stdout);
        }
        if (data.stderr) {
          return console.log(data.stderr);
        }
      }).on('cleaned', (data) => {
        return console.log(`   ${data.input} -> ${data.output} (` + (data.skip ? 'ALREADY ' : '') + 'CLEANED)');
      }).on('error', (error) => {
        if (error.input != null) {
          console.log(`!! ${error.input} -> ${error.output} FAILED`);
        } else {
          console.log("!! svgink conversion error");
        }
        return console.log(error);
      });
    }
    if (Array.isArray(filenames)) {
      results = [];
      for (l = 0, len = filenames.length; l < len; l++) {
        filename = filenames[l];
        results.push(processor.convertTo(filename, settings.formats));
      }
      return results;
    } else {
      return processor.convertTo(filenames, settings.formats);
    }
  };

  inputRequire = function(filename, settings = getSettings(), dirname) {
    filename = resolve(dirname, filename);
    return Input.recognize(filename, void 0, settings);
  };

  glob = function(pattern, options) {
    //# Support backslash in Windows path as long as not meaningful escape.
    //# [code from svgink]
    if (process.platform === 'win32') {
      pattern = pattern.replace(/\\($|[^\*\+\?\!\|\@\(\)\[\]\{\}])/g, '/$1');
    }
    return require('glob').globSync(pattern, options).sort();
  };

  isGlob = function(pattern, options) {
    return require('glob').hasMagic(pattern, options);
  };

  match = function(filename, pattern, options) {
    //# 'glob' library uses 'minimatch' to match filenames against glob patterns.
    return Boolean(require('minimatch').match([filename], pattern, options));
  };

  filter = function(filenames, pattern, options) {
    return require('minimatch').match(filenames, pattern, options);
  };

  dashArgRegExp = /^-([a-zA-Z]{2,})$/;

  inputCache = new Map(); // maps filenames to previously loaded `Input`s

  currentInits = null; // array of currently initialized `Input`s

  Driver = class Driver extends HasSettings {
    constructor(parent1 = getDriver()) {
      super();
      this.parent = parent1;
    }

    //@reset()  # called in main() instead
    reset() {
      var key, ref, ref1, results;
      /*
      Reset settings to a clone of the parent's, empty initialized modules,
      and empty global `share` object (while preserving object identity),
      as if we were running `svgtiler` from scratch.
      */
      this.settings = cloneSettings((ref = (ref1 = this.parent) != null ? ref1.settings : void 0) != null ? ref : defaultSettings, true);
      this.inits = currentInits = [];
      this.initsLength = 0;
      results = [];
      for (key in globalShare) {
        results.push(delete globalShare[key]);
      }
      return results;
    }

    loadMaketile() {
      var filenames;
      if (this.maketile !== void 0) {
        return this.maketile;
      }
      filenames = glob(this.settings.maketile, {
        nodir: true
      });
      return this.maketile = filenames.length ? inputRequire(filenames.sort()[0], this.settings) : null;
    }

    addInit(input) {
      this.maybeInit();
      //# Now @inits == currentInits and @initsLength == currentInits.length
      this.inits.push(input);
      this.initsLength++;
      return input.doInit();
    }

    maybeInit() {
      var i, init, key, l, len, len1, n, ref, reset, start;
      /*
      Check whether @inits list changed and (re)initialize if so.
      If the list changed by appending items, just initialize new items.
      Otherwise, reset global `share` object (without changing object identity)
      and re-initialize all items from scratch to restore side effects.
      */
      //# If @inits has grown without our knowledge, de-alias init lists.
      if (this.initsLength !== this.inits.length) {
        this.inits = this.inits.slice(0, this.initsLength);
      }
      //# Cheap case: init lists are (still) identical.  Nothing to do.
      if (this.inits === currentInits) {
        return;
      }
      reset = currentInits.length > this.initsLength;
      if (!reset) {
//# currentInits is shorter or equal; check for prefix match
        for (i = l = 0, len = currentInits.length; l < len; i = ++l) {
          init = currentInits[i];
          if (init !== this.inits[i]) {
            reset = true;
            break;
          }
        }
      }
      if (reset) {
        for (key in globalShare) {
          delete globalShare[key];
        }
        start = 0;
      } else {
        start = currentInits.length;
      }
      ref = this.inits.slice(start);
      for (n = 0, len1 = ref.length; n < len1; n++) {
        init = ref[n];
        init.doInit();
      }
      return currentInits = this.inits;
    }

    main(args = process.argv.slice(2)) {
      return runWithDriver(this, () => {
        var append, arg, base1, char, exists, file, files, i, input, key, l, len, numFileArgs, oldDir, ranMaketile, ref, ref1, ref2, ref3, ref4, ref5, ref6, showHelp, stack, stat, svgs, value;
        this.reset();
        showHelp = 'No filename arguments and no Maketile to run. Try `svgtiler --help`';
        ranMaketile = false;
        numFileArgs = 0;
        this.inits = []; // array of objects to call doInit() on
        stack = []; // {settings, inits} objects for implementing parens
        // `for arg, i in args` but allowing i to advance and args to get appended to
        i = 0;
        while (true) {
          //# Automatically run Maketile if we're out of arguments
          //# and haven't processed any files yet.
          if (i >= args.length && !numFileArgs && !ranMaketile && (this.loadMaketile() != null)) {
            ranMaketile = true;
            showHelp = false;
            if (this.maketile.makeRule != null) {
              this.maketile.doInit();
              console.log(`** ${this.maketile.filename} (default)`);
              if (!this.maketile.makeRule('')) {
                console.log(`Maketile '${this.maketile.filename}' does not define a default rule`);
              }
            } else {
              console.warn(`Unrecognized Maketile '${this.maketile.filename}' of type '${(ref = this.maketile.constructor) != null ? ref.name : void 0}'`); // Args or Mapping
            }
          }
          if (i >= args.length) {
            break;
          }
          //# Split up single-dash arguments with multiple options like -pP
          arg = args[i];
          if (typeof arg === 'string' && ((match = arg.match(dashArgRegExp)) != null)) {
            splice.apply(args, [i, i - i + 1].concat(ref1 = (function() {
              var l, len, ref2, results;
              ref2 = match[1];
              results = [];
              for (l = 0, len = ref2.length; l < len; l++) {
                char = ref2[l];
                results.push(`-${char}`);
              }
              return results;
            })())), ref1;
            arg = args[i];
          }
          //# Main argument handling
          switch (arg) {
            case '-h':
            case '--help':
              help();
              return;
            case '-v':
            case '--verbose':
              this.settings.verbose++;
              break;
            case '-f':
            case '--force':
              this.settings.force = true;
              break;
            case '-m':
            case '--margin':
              this.settings.keepMargins = true;
              break;
            case '--uneven':
              this.settings.keepUneven = true;
              break;
            case '--hidden':
              this.settings.keepHidden = true;
              break;
            case '--tw':
            case '--tile-width':
              i++;
              arg = parseFloat(args[i]);
              if (arg != null) {
                this.settings.forceWidth = arg;
              } else {
                console.warn(`Invalid argument to --tile-width: ${args[i]}`);
              }
              break;
            case '--th':
            case '--tile-height':
              i++;
              arg = parseFloat(args[i]);
              if (arg != null) {
                this.settings.forceHeight = arg;
              } else {
                console.warn(`Invalid argument to --tile-height: ${args[i]}`);
              }
              break;
            case '--bg':
            case '--background':
              i++;
              this.settings.background = args[i];
              break;
            case '-s':
            case '--share':
              i++;
              [key, ...value] = args[i].split('=');
              this.addInit(new ShareSetter(key, value.join('='), this.settings)); // ignore later =s
              break;
            case '-o':
            case '--output':
              i++;
              this.settings.outputDir = args[i];
              break;
            case '-O':
            case '--output-stem':
              i++;
              this.settings.outputStem = args[i];
              break;
            case '--os':
            case '--output-svg':
              i++;
              this.settings.outputDirExt['.svg'] = args[i];
              break;
            case '--op':
            case '--output-pdf':
              i++;
              this.settings.outputDirExt['.pdf'] = args[i];
              break;
            case '--oP':
            case '--output-png':
              i++;
              this.settings.outputDirExt['.png'] = args[i];
              break;
            case '--ot':
            case '--output-tex':
              i++;
              this.settings.outputDirExt['.svg_tex'] = args[i];
              break;
            case '--clean':
              this.settings.clean = true;
              break;
            case '-i':
            case '--inkscape':
              i++;
              this.settings.inkscape = args[i];
              break;
            case '--maketile':
              i++;
              this.settings.maketile = args[i];
              break;
            case '-p':
            case '--pdf':
              this.settings.formats.push('pdf');
              break;
            case '-P':
            case '--png':
              this.settings.formats.push('png');
              break;
            case '-t':
            case '--tex':
              this.settings.texText = true;
              break;
            case '--no-sanitize':
              this.settings.sanitize = false;
              break;
            case '--no-overflow':
              this.settings.overflowDefault = null; // no default
              break;
            case '--no-inline':
              this.settings.inlineImages = false;
              break;
            case '--use-href':
              this.settings.useHref = true;
              break;
            case '--use-defs':
              this.settings.useDefs = true;
              break;
            case '--use-data':
              this.settings.useData = true;
              break;
            case '-j':
            case '--jobs':
              i++;
              arg = parseInt(args[i], 10);
              if (arg) {
                this.settings.jobs = arg;
              } else {
                console.warn(`Invalid argument to --jobs: ${args[i]}`);
              }
              break;
            case '(':
              stack.push({
                settings: cloneSettings(this.settings),
                inits: [...this.inits]
              });
              break;
            case ')':
              if (stack.length) {
                ({
                  settings: this.settings,
                  inits: this.inits
                } = stack.pop());
              } else {
                console.warn("Unmatched ')'");
                this.reset();
              }
              break;
            default:
              showHelp = false;
              numFileArgs++;
              //# If argument is not a string (e.g. Mapping or Style),
              //# or is a string that corresponds to an existing filename
              //# with an extension (containing '.'), process it directly.
              exists = typeof arg !== 'string' || inputCache.has(arg);
              if (!exists) {
                try {
                  exists = fs.statSync(arg);
                  if (!(exists.isDirectory() || arg.includes('.'))) {
                    exists = false;
                  }
                } catch (error1) {}
              }
              if (exists) {
                files = [arg];
              //# Otherwise, try matching as a glob pattern.
              } else if (isGlob(arg)) {
                files = glob(arg);
              } else {
                //# Otherwise, check for a matching rule in the Maketile.
                files = [];
                if (arg.includes('.')) {
                  console.warn(`No such file or directory '${arg}', and not a valid Maketile rule name`);
                } else if (this.loadMaketile() != null) {
                  console.log(`** ${this.maketile.filename} - ${arg}`);
                  if (typeof (base1 = this.maketile).doInit === "function") {
                    base1.doInit();
                  }
                  if (!this.maketile.makeRule(arg)) {
                    console.warn(`Maketile '${this.maketile.filename}' does not define rule '${arg}'`);
                  }
                } else {
                  console.warn(`No such file or directory '${arg}', and no Maketile to define rules`);
                }
              }
              append = i + 1; // where to append Args
              for (l = 0, len = files.length; l < len; l++) {
                file = files[l];
                if (typeof file === 'string') {
                  //# Check for input already in cache (e.g. already loaded Mapping)
                  if (inputCache.has(file)) {
                    console.log('*', file, '(cached)');
                    input = inputCache.get(file);
                    input.settings = this.settings;
                    //# Reset filename and dirname in case we're in a new directory
                    input.settings.filename = file;
                    input.settings.dirname = path.dirname(file);
                  } else {
                    //# Check for directory
                    if (exists instanceof fs.Stats) {
                      stat = exists;
                    } else {
                      try {
                        stat = fs.statSync(file);
                      } catch (error1) {}
                    }
                    if (stat != null ? stat.isDirectory() : void 0) {
                      //# Recursively run svgtiler within directory
                      console.log('**', file, '(directory)');
                      oldDir = process.cwd();
                      process.chdir(file);
                      (new Driver(this)).main([]);
                      process.chdir(oldDir);
                      console.log('..', file, '(end of directory)');
                      continue;
                    } else {
                      //# Regular file
                      console.log('*', file);
                      this.maybeInit();
                      input = inputRequire(file, this.settings);
                      if (input instanceof Mapping) {
                        /*
                        Cache Mapping files, to avoid rebuilding Mapping objects.
                        Don't cache drawing files, as we might have changed options
                        like `keepMargins` and `keepUneven` which affect parsing.
                        */
                        inputCache.set(file, input);
                      }
                    }
                  }
                } else if ((file != null) && typeof file === 'object') {
                  console.log('*', (ref2 = file.constructor) != null ? ref2.name : void 0, (ref3 = file.filename) != null ? ref3 : file);
                } else {
                  input = file;
                  continue; // skip boolean, number, null, undefined
                }
                if (input instanceof Mapping) {
                  this.settings.mappings.push(input);
                  this.addInit(input);
                } else if (input instanceof Style) {
                  this.settings.styles.push(input);
                } else if (input instanceof Drawing || input instanceof Drawings) {
                  this.maybeInit();
                  svgs = input.render(this.settings);
                  //# Convert to any additional formats.  Even if SVG files didn't
                  //# change, we may not have done these conversions before or in the
                  //# last run of SVG Tiler, so let svgink compare mod times and decide.
                  convert(svgs, this.settings);
                  //# Reset -O output filename stem override unless it uses `*`.
                  if ((this.settings.outputStem != null) && !this.settings.outputStem.includes('*')) {
                    this.settings.outputStem = null;
                  }
                } else if (input instanceof SVGFile) {
                  convert(input.filename, this.settings);
                } else if (input instanceof Args) {
                  splice.apply(args, [append, append - append].concat(ref4 = input.args)), ref4;
                  append += input.args.length;
                } else if (input != null) {
                  console.log(`Unrecognized file '${file}' of type '${input != null ? (ref5 = input.constructor) != null ? ref5.name : void 0 : void 0}'`);
                } else if ((file != null) && typeof file === 'object' && (file.hasOwnProperty('map') || Mapping.properties.some(function(prop) {
                  return file.hasOwnProperty(prop);
                }))) {
                  input = new Mapping(file, {
                    settings: this.settings
                  });
                  this.settings.mappings.push(input);
                  this.addInit(input);
                } else {
                  console.log(`Unrecognized file '${file}' of type '${file != null ? (ref6 = file.constructor) != null ? ref6.name : void 0 : void 0}'`);
                }
              }
          }
          i++;
        }
        if (showHelp) {
          console.log(showHelp);
        }
      });
    }

    //help()
    run(...protoArgs) {
      var arg, args, l, len;
      args = [];
      for (l = 0, len = protoArgs.length; l < len; l++) {
        arg = protoArgs[l];
        if (typeof arg === 'string') {
          args.push(...(parseIntoArgs(arg)));
        } else if (Array.isArray(arg)) {
          args.push(...(arg.flat(2e308))); // Mapping, Style, etc.
        } else {
          args.push(arg);
        }
      }
      console.log('> svgtiler', ((function() {
        var len1, n, ref, results;
        results = [];
        for (n = 0, len1 = args.length; n < len1; n++) {
          arg = args[n];
          if (typeof arg === 'string') {
            results.push(arg);
          } else if ((arg != null ? (ref = arg.constructor) != null ? ref.name : void 0 : void 0) != null) {
            if (arg.filename != null) {
              results.push(`[${arg.constructor.name} ${arg.filename}]`);
            } else {
              results.push(`[${arg.constructor.name}]`);
            }
          } else {
            results.push(`[${typeof arg} ${arg}]`);
          }
        }
        return results;
      })()).join(' '));
      return this.main(args);
    }

  };

  main = function(...args) {
    return new Driver().main(...args);
  };

  run = function(...args) {
    return new Driver().run(...args);
  };

  needVersion = function(constraints) {
    if (metadata.version === '(web)') {
      return;
    }
    if (require('semver/functions/satisfies')(metadata.version, constraints)) {
      return true;
    } else {
      throw new SVGTilerError(`SVG Tiler version ${metadata.version} does not satisfy ${constraints} \nPlease upgrade SVG Tiler via: npm install -g svgtiler@latest\n`);
    }
  };

  svgtiler = Object.assign(run, {
    SVGContent,
    SVGWrapped,
    SVGSymbol,
    unrecognizedSymbol,
    Mapping,
    Mappings,
    ASCIIMapping,
    JSMapping,
    CoffeeMapping,
    static: wrapStatic,
    Drawing,
    AutoDrawing,
    ASCIIDrawing,
    DSVDrawing,
    SSVDrawing,
    CSVDrawing,
    TSVDrawing,
    PSVDrawing,
    Drawings,
    XLSXDrawings,
    Style,
    CSSStyle,
    StylusStyle,
    Styles,
    Args,
    ParsedArgs,
    SVGFile,
    extensionMap,
    Input,
    DummyInput,
    ArrayWrapper,
    Render,
    getRender,
    runWithRender,
    id: globalId,
    def: globalDef,
    background: globalBackground,
    add: globalAdd,
    Context,
    getContext,
    getContextString,
    runWithContext,
    SVGTilerError,
    SVGNS,
    XLINKNS,
    escapeId,
    Driver,
    main,
    run,
    convert,
    inputCache,
    renderDOM,
    glob,
    isGlob,
    match,
    filter,
    require: inputRequire,
    defaultSettings,
    getSettings,
    cloneSettings,
    getSetting,
    getOutputDir,
    share: globalShare,
    needVersion,
    version: metadata.version
  });

  if (typeof module !== "undefined" && module !== null) {
    module.exports = svgtiler;
  }

  if (typeof window !== "undefined" && window !== null) {
    window.svgtiler = svgtiler;
  }

  if ((typeof module !== "undefined" && module !== null) && (typeof require !== "undefined" && require !== null ? require.main : void 0) === module && (typeof window === "undefined" || window === null)) {
    paths = [
      //# Enable require('svgtiler') (as autoimported by `svgtiler` access)
      //# to load this module (needed if the module is installed globally).
      path.join(__dirname,
      '..',
      '..'),
      //# Enable require('preact') (as autoimported by `preact` access)
      //# to load SVG Tiler's copy of preact.
      path.join(__dirname,
      '..',
      'node_modules')
    ];
    if (process.env.NODE_PATH) {
      paths.push(process.env.NODE_PATH);
    }
    process.env.NODE_PATH = paths.join((process.platform === 'win32' ? ';' : ':'));
    require('module').Module._initPaths();
    main();
  }

}).call(this);
