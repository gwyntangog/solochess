#!/usr/bin/env node
;
var EventEmitter, Inkscape, InkscapeError, SVGProcessor, child_process, defaultSettings, fs, fsNormal, help, invalidFilename, main, metadata, os, path;

//log = require 'why-is-node-running'
metadata = require('./package.json');

child_process = require('child_process');

EventEmitter = require('events');

fs = require('fs/promises');

fsNormal = require('fs');

os = require('os');

path = require('path');

defaultSettings = {
  //# Whether to force conversion, even if SVG file is older than target.
  force: false,
  //# Whether to run jobs with relative paths, or resolve to absolute paths.
  //# Absolute paths support changing directories between jobs, but relative
  //# paths are shorter and might bypass some limitations.
  relative: false,
  //# Directories to output all or some files.
  outputDir: null, //# default: same directory as input
  outputDirExt: { //# by extension; default is to use outputDir
    '.pdf': null,
    '.png': null
  },
  //# Delete output files instead of creating them, like `make clean`.
  clean: false,
  //# Path to inkscape.  Default searches PATH.
  inkscape: 'inkscape',
  //# Maximum number of Inkscapes to run in parallel.
  //# Default = number of physical CPU cores (assuming hyperthreading).
  jobs: (function() {
    try {
      return Math.max(1, Math.floor(os.cpus().length / 2));
    } catch (error1) {
      return 1;
    }
  })(),
  //# If an Inkscape process sits idle for this many milliseconds, close it.
  //# Default = 1 minute.  Set to null to disable.
  idle: 60000,
  //# If an Inkscape fails to start shell for this many milliseconds, fail.
  //# Default = 1 minute.  Set to null to disable.
  startTimeout: 60000,
  //# If an Inkscape fails to close for this many milliseconds, kill it.
  //# Default = 1 second.  Set to null to disable.
  quitTimeout: 1000,
  //# Wait for an input file to stop changing for this many milliseconds
  //# before watch triggers conversion.  Default = 1 second.
  settle: 1000,
  //# Whether to sanitize PDF output by blanking out /CreationDate.
  sanitize: true,
  //# Buffer size for sanitization.
  bufferSize: 16 * 1024
};

invalidFilename = (filename) => {
  return /^\s|\s$|;/.test(filename);
};

InkscapeError = class InkscapeError extends Error {
  constructor(message) {
    super(message);
    this.name = 'InkscapeError';
  }

};

Inkscape = class Inkscape {
  constructor(settings1 = defaultSettings) {
    this.settings = settings1;
  }

  open(initialUnref) {
    //# Start Inkscape process.  Returns a Promise.
    //# `initialUnref` specifies whether to unref the Inkscape process
    //# before it finishes starting; set true for secondary Inkscape processes.
    return new Promise((resolve1, reject1) => {
      var handle, j, len, ref;
      this.resolve = resolve1;
      this.reject = reject1;
      this.stdout = this.stderr = '';
      this.dead = this.ready = this.started = false;
      //console.log (new Date), 'start'
      this.process = child_process.spawn(this.settings.inkscape, ['--shell']);
      ref = [this.process.stdin, this.process.stdout, this.process.stderr];
      //# Node can close independent of pipes; rely on @process.ref/unref
      for (j = 0, len = ref.length; j < len; j++) {
        handle = ref[j];
        handle.unref();
      }
      if (initialUnref) {
        //# Don't wait for a new Inkscape to start, unless requested.
        this.process.unref();
      }
      if (this.settings.startTimeout) {
        //# Check for failure to start.
        this.timeout = setTimeout(() => {
          return this.reject(new InkscapeError(`'${this.settings.inkscape} --shell' produced no '> ' prompt after ${this.settings.startTimeout / 1000} seconds`));
        }, this.settings.startTimeout);
      }
      this.timeout.unref();
      this.process.stderr.on('data', (buf) => {
        return this.stderr += buf;
      });
      this.process.stdout.on('data', (buf) => {
        var stderr, stdout;
        this.stdout += buf;
        if (this.stdout === '> ' || this.stdout.endsWith('\n> ')) {
          if ((this.job != null) || !initialUnref) {
            //console.log (new Date), 'ready' unless @started
            //# Inkscape just started up, or finished a job.  Allow Node to exit.
            //# In the first case, don't call unref() a second time.
            this.process.unref();
          }
          this.ready = this.started = true;
          if (this.timeout != null) {
            clearTimeout(this.timeout);
          }
          if (this.settings.idle != null) {
            this.timeout = setTimeout((() => {
              return this.close();
            }), this.settings.idle);
            this.timeout.unref();
          }
          stdout = this.stdout.replace(/> $/, '').replace(/^([^\n]*)(\n|$)/, (match, firstLine) => { // next prompt
            var ref1;
            //# Remove first line of output if it includes the job input,
            //# possibly with some complex readline output after first \r.
            if ((ref1 = this.cmd) != null ? ref1.startsWith(firstLine.replace(/\r[^]*$/, '')) : void 0) {
              return '';
            } else {
              return match;
            }
          });
          stderr = this.stderr;
          this.stdout = this.stderr = '';
          if (typeof this.resolve === "function") {
            this.resolve({...this.job, stdout, stderr});
          }
          return this.resolve = this.reject = this.job = this.cmd = null;
        }
      });
      this.process.on('error', (error) => {
        var key, ref1, value;
        this.closed();
        if (this.reject != null) {
          if (this.job != null) {
            ref1 = this.job;
            for (key in ref1) {
              value = ref1[key];
              error[key] = value;
            }
          }
          return this.reject(error);
        } else {
          throw new InkscapeError(`Uncaught Inkscape error: ${error.message}`);
        }
      });
      return this.process.on('exit', (status, signal) => {
        var error, key, message, ref1, value;
        if (this.dead) { // ignore exit event after error event
          return;
        }
        this.closed();
        if (status || signal || !this.started) {
          message = `'${this.settings.inkscape} --shell' exited ` + (status ? `with status ${status}` : signal ? `with signal ${signal}` : "without status or signal before '> ' prompt");
          if (this.reject != null) {
            error = new InkscapeError(message);
            if (this.job != null) {
              ref1 = this.job;
              for (key in ref1) {
                value = ref1[key];
                error[key] = value;
              }
            }
            error.status = status;
            error.signal = signal;
            this.reject(error);
            return this.resolve = this.reject = this.job = this.cmd = null;
          } else {
            throw new InkscapeError(`Uncaught Inkscape crash: ${message}`);
          }
        } else {
          if (typeof this.resolve === "function") {
            this.resolve({
              stdout: this.stdout,
              stderr: this.stderr
            });
          }
          return this.resolve = this.reject = null;
        }
      });
    });
  }

  close() {
    //# Gently close Inkscape process, or if it doesn't respond, kill it.
    //# Returns a Promise.
    return new Promise((resolve1, reject1) => {
      this.resolve = resolve1;
      this.reject = reject1;
      //@process.stdin.write 'quit\n'
      this.process.stdin.end();
      this.process.unref();
      if (this.settings.quitTimeout != null) {
        this.timeout = setTimeout(() => {
          if (!this.dead) {
            return this.process.kill();
          }
        }, this.settings.quitTimeout);
        return this.timeout.unref();
      }
    });
  }

  closed() {
    //# Inkscape process has closed; turn everything off.
    this.dead = true;
    this.ready = false;
    if (this.timeout != null) {
      return clearTimeout(this.timeout);
    }
  }

  run(job) {
    var ref, ref1;
    //# Send job to Inkscape.  Returns a Promise.
    //# Job can be a string to send to the shell,
    //# or an object with a `job` string property,
    //# or an object with `input` and `output` properties for conversion.
    if (!(this.ready && !this.job)) {
      throw new InkscapeError('Attempt to run Inkscape job before ready');
    }
    this.ready = false;
    this.process.ref();
    if (this.timeout != null) {
      clearTimeout(this.timeout);
    }
    if (typeof job === 'string') {
      job = {job};
    }
    this.job = job;
    if ((job != null ? job.job : void 0) != null) {
      this.cmd = job.job.replace(/\n+$/, '');
    } else if (((job != null ? job.input : void 0) != null) && (job.output != null)) {
      this.cmd = [`file-open:${(ref = this.job.inputAbs) != null ? ref : this.job.input}`, `export-filename:${(ref1 = job.outputAbs) != null ? ref1 : this.job.output}`, 'export-overwrite', 'export-do'].join(';');
    } else {
      //console.log @cmd
      throw new InkscapeError(`Invalid Inkscape job: ${this.job}`);
    }
    this.cmd += '\n';
    return new Promise((resolve1, reject1) => {
      this.resolve = resolve1;
      this.reject = reject1;
      return this.process.stdin.write(this.cmd);
    });
  }

};

SVGProcessor = class SVGProcessor extends EventEmitter {
  constructor(settings1 = defaultSettings) {
    super();
    this.settings = settings1;
    this.inkscapes = [];
    this.queue = [];
    this.spawning = false;
    this.jobs = 0;
  }

  async convertGlob(input, formats) {
    var type;
    //# Convert directory or glob pattern into specified format(s).
    //# Use input/converted/error events to consume results.
    this.jobs++; // treat glob as an additional job, to avoid premature exit
    ({type, input} = (await this.parseGlob(input)));
    if (type === 'file') {
      this.jobs--; // will be immediately incremented by convert job
      return this.convertTo(input, formats);
    }
    return this.makeGlob(input, {
      nodir: true
    }).on('match', (file) => {
      return this.convertTo(file, formats);
    }).on('end', (matches) => {
      if (!matches.length) {
        console.log(`! No files found matching '${input}'`);
      }
      this.jobs--; // finished glob job
      if (this.waiting) { // resolve wait() in case this was last job
        return this.update();
      }
    });
  }

  escapeGlob(input) {
    return input.replace(/[\*\+\?\!\|\@\(\)\[\]\{\}]/g, '\\$&');
  }

  async parseGlob(input) {
    var stat, type;
    try {
      stat = (await fs.stat(input));
    } catch (error1) {}
    if (stat != null ? stat.isFile() : void 0) {
      type = 'file';
    } else {
      if (stat != null ? stat.isDirectory() : void 0) { // directory treated as /*.svg glob
        type = 'dir';
        //# glob requires forward slashes for directory separators.
        if (os.platform() === 'win32') {
          input = input.replace(/\\/g, '/');
        }
        //# Escape all glob syntax, as this is a real path.
        input = this.escapeGlob(input);
        input += '/*.svg'; // path doesn't exist, so treat as glob
      } else {
        type = 'glob';
        //# Support backslash in Windows path as long as not meaningful escape.
        if (os.platform() === 'win32') {
          input = input.replace(/\\($|[^\*\+\?\!\|\@\(\)\[\]\{\}])/g, '/$1');
        }
      }
    }
    return {type, input};
  }

  makeGlob(input, options = {}) {
    var Glob;
    ({Glob} = require('glob'));
    return new Glob(input, options).on('error', (error) => {
      return this.emit('error', error);
    });
  }

  convertTo(input, format, emit = true) {
    var dir, error, f, output, parsed, promise;
    if (emit) {
      //# Convert input filename to output file format(s), e.g.:
      //# 'pdf', 'png', '.pdf', '.png', or ['pdf', 'png'].
      //# Generates output filename(s) using `settings.outputDir*`
      //# and then calls `convert`.
      //# Returns a Promise or Array of Promises (when `format` is an Array).
      //# Each Promise has additional `output` property with generated filename.
      this.emit('input', input);
    }
    if (Array.isArray(format)) {
      if (!format.length) { // job immediately finished if no formats
        this.update();
      }
      return (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = format.length; j < len; j++) {
          f = format[j];
          results.push(this.convertTo(input, f, false));
        }
        return results;
      }).call(this);
    }
    if (!format.startsWith('.')) {
      //# Single format case.  Generate output filename.
      format = `.${format}`;
    }
    parsed = path.parse(input);
    delete parsed.base; // use ext instead
    if (parsed.ext !== format) {
      parsed.ext = format;
    } else {
      parsed.ext += format;
    }
    if (this.settings.outputDirExt[format] != null) {
      dir = this.settings.outputDirExt[format];
    } else if (this.settings.outputDir != null) {
      dir = this.settings.outputDir;
    }
    if (dir != null) {
      try {
        //# Try to make output directory, synchronously to avoid multiple
        //# async threads trying to make the same directory at once.
        fsNormal.mkdirSync(dir, {
          recursive: true
        });
      } catch (error1) {
        error = error1;
        console.log(`! Failed to make directory '${dir}': ${error.message}`);
      }
      parsed.dir = dir;
    }
    output = path.format(parsed);
    //# Call convert.
    promise = this.convert(input, output);
    promise.output = output;
    return promise;
  }

  convert(input, output) {
    var cleaned, inputAbs, outputAbs;
    //# Convert input filename to output filename, and then sanitize,
    //# unless output is newer than input or forced.  Returns a Promise.
    if (!this.settings.relative) {
      inputAbs = path.resolve(input);
      outputAbs = path.resolve(output);
    }
    this.jobs++;
    if (this.settings.clean) {
      cleaned = {input, output, inputAbs, outputAbs};
      return fs.unlink(outputAbs).then(() => {
        this.emit('cleaned', cleaned);
        return cleaned;
      }).catch((error) => {
        if (error.code === 'ENOENT') {
          cleaned.skip = true;
          return this.emit('cleaned', cleaned);
        } else {
          return this.emit('error', error);
        }
      }).finally(() => {
        this.jobs--;
        return this.update();
      });
    }
    return new Promise(async(resolve, reject) => {
      var filename, inputStat, j, len, outputStat, ref;
      ref = [inputAbs != null ? inputAbs : input, outputAbs != null ? outputAbs : output];
      for (j = 0, len = ref.length; j < len; j++) {
        filename = ref[j];
        if (invalidFilename(filename)) {
          this.jobs--;
          reject(new InkscapeError(`Inkscape shell does not support filenames with semicolons or leading/trailing spaces: ${filename}`));
          if (this.waiting) { // resolve wait() in case this was last job
            this.update();
          }
          return;
        }
      }
      //# Compare input and output modification times, unless forced.
      if (!this.settings.force) {
        try {
          outputStat = (await fs.stat(output));
          inputStat = (await fs.stat(input));
        } catch (error1) {}
      }
      if (!((inputStat != null) && (outputStat != null) && inputStat.mtime < outputStat.mtime)) {
        this.queue.push({
          job: {input, output, inputAbs, outputAbs},
          resolve,
          reject
        });
        this.update();
      } else {
        this.jobs--;
        resolve({
          input,
          output,
          inputAbs,
          outputAbs,
          skip: true
        });
        if (this.waiting) { // resolve wait() in case last job is skipped
          this.update();
        }
      }
      return void 0;
    }).then((result) => {
      this.emit('converted', result);
      return result;
    }).catch((error) => {
      return this.emit('error', error); // throws if no error listeners
    });
  }

  run(job) {
    //# Queue job for Inkscape to run.  Returns a Promise.
    //# Job can be a string to send to the shell,
    //# or an object with a `job` string property,
    //# or an object with `input` and `output` properties for conversion.
    this.jobs++;
    if (typeof job === 'string') {
      job = {job};
    }
    return new Promise((resolve, reject) => {
      this.queue.push({job, resolve, reject});
      return this.update();
    }).then((result) => {
      this.emit('ran', result);
      return result;
    }).catch((error) => {
      return this.emit('error', error); // throws if no error listeners
    });
  }

  wait() {
    //# Returns a Promise that resolves once all pending jobs are complete.
    //# Only one wait() can be active at a time.
    return new Promise((waiting) => {
      this.waiting = waiting;
      return this.update();
    });
  }

  close() {
    //# Close all Inkscape processes once all pending jobs are complete.
    //# Returns a Promise.
    this.closing = true;
    return this.wait();
  }

  update() {
    var inkscape, j, len, ref;
    //# Potentially push jobs from queue or closing to Inkscape processes.
    if (!(this.queue.length || this.waiting || this.closing)) {
      return;
    }
    //# Filter out any Inkscape processes that died, e.g. from idle timeout.
    this.inkscapes = (function() {
      var j, len, ref, results;
      ref = this.inkscapes;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        inkscape = ref[j];
        if (!inkscape.dead) {
          results.push(inkscape);
        }
      }
      return results;
    }).call(this);
    //# Check for completed waiting.
    if (this.waiting && this.jobs <= 0) {
      //# Schedule close() promise to resolve after job promise resolves.
      setTimeout(() => {
        this.waiting();
        return this.waiting = null;
      }, 0);
      return;
    }
    ref = this.inkscapes;
    //# Give jobs to any ready Inkscape processes.
    for (j = 0, len = ref.length; j < len; j++) {
      inkscape = ref[j];
      if (inkscape.ready) {
        if (this.queue.length) {
          this.runNow(inkscape, this.queue.shift());
          if (!(this.queue.length || this.closing)) {
            return;
          }
        } else if (this.closing) {
          inkscape.close();
        }
      }
    }
    //# If we still have jobs, start another Inkscape process to run them.
    //# On Windows, spawning is slow and spawning multiple Inkscapes at once
    //# slows down all spawns (including the first), so only spawn one at a time.
    //# On Linux, spawning is fast, so this isn't a big penalty.
    //# This also avoids spawning many Inkscapes if everything can be finished
    //# quickly with the first spawned Inkscape.
    if (!this.spawning && this.queue.length && this.inkscapes.length < this.settings.jobs) {
      this.spawning = true;
      this.inkscapes.push(inkscape = new Inkscape(this.settings));
      inkscape.open(this.inkscapes.length > 1).then(() => {
        this.spawning = false;
        return this.update();
      }).catch((error) => {
        throw new InkscapeError(`Failed to spawn Inkscape: ${error.message}` + (error.code === 'ENOENT' ? ' (check PATH environment variable?)' : ''));
      });
    }
    return void 0;
  }

  runNow(inkscape, {job, resolve, reject}) {
    return inkscape.run(job).then(async(data) => {
      var ref;
      this.update();
      if (job.output != null) {
        await this.sanitize((ref = job.outputAbs) != null ? ref : job.output);
      }
      return data;
    }).then((data) => {
      resolve(data);
      this.jobs--;
      return this.update();
    }).catch((error) => {
      var key, value;
      for (key in job) {
        value = job[key];
        error[key] = value;
      }
      return reject(error);
    });
  }

  async sanitize(output) {
    var buffer, file, fileSize, match, position, readSize, string;
    //# Sanitize generated file.  Returns a Promise.
    if (!this.settings.sanitize) {
      return;
    }
    switch (false) {
      case !output.endsWith('.pdf'):
        //# Blank out /CreationDate in PDF for easier version control.
        //# Replace these commands with spaces to avoid in-file pointer errors.
        buffer = Buffer.alloc(this.settings.bufferSize);
        fileSize = ((await fs.stat(output))).size;
        position = Math.max(0, fileSize - this.settings.bufferSize);
        file = (await fs.open(output, 'r+'));
        readSize = (await file.read(buffer, 0, this.settings.bufferSize, position));
        string = buffer.toString('binary'); //# must use single-byte encoding!
        match = /\/CreationDate\s*\((?:[^()\\]|\\[^])*\)/.exec(string);
        if (match != null) {
          await file.write(' '.repeat(match[0].length), position + match.index);
        }
        return (await file.close());
    }
  }

  async watch(inputs, formats) {
    var array, handle, input, j, len, status, timeouts, type, watchFile, watchers;
    if (typeof inputs === 'string') {
      inputs = [inputs];
    }
    if (formats.length === 1) {
      formats = formats[0];
    }
    array = Array.isArray(formats);
    watchers = {};
    timeouts = {};
    status = {};
    handle = (input, force) => {
      if (timeouts[input] != null) {
        clearTimeout(timeouts[input]);
      }
      if (status[input] === 'converting') {
        return status[input] = 'changed';
      } else if (!status[input]) {
        //# Restart watcher in case inode changed.
        if (watchers[input] != null) {
          watchers[input].close();
          delete watchers[input];
          watchFile(input);
        }
        //# Wait for file to settle.
        return timeouts[input] = setTimeout(() => {
          var oldSettings;
          //# If timeout actually resolves, file has settled.
          status[input] = 'converting';
          if (force != null) {
            oldSettings = this.settings;
            this.settings = {...oldSettings, force};
          }
          return (array ? Promise.allSettled(this.convertTo(input, formats)) : this.convertTo(input, formats)).finally(() => {
            var current;
            if (force != null) {
              this.settings = oldSettings;
            }
            //# If file changed during conversion, schedule forced conversion.
            current = status[input];
            delete status[input];
            if (current === 'changed') {
              return handle(input, true);
            }
          });
        }, this.settings.settle);
      }
    };
    watchFile = (input) => {
      var error;
      try {
        return watchers[input] != null ? watchers[input] : watchers[input] = fsNormal.watch(input, () => {
          return handle(input);
        }).on('error', (error) => {
          return this.emit('error', error);
        });
      } catch (error1) {
        error = error1;
        if (error.code === 'ENOENT') {
          console.log(`. ${input} no longer exists`);
          //# Cancel conversion job about to be started
          return setImmediate(() => {
            if (timeouts[input] != null) {
              return clearTimeout(timeouts[input]);
            }
          });
        } else {
          return this.emit('error', error);
        }
      }
    };
    for (j = 0, len = inputs.length; j < len; j++) {
      input = inputs[j];
      ({type, input} = (await this.parseGlob(input)));
      if (type === 'file') {
        watchFile(input);
      } else {
        ((input) => {
          var find, watchDir;
          watchDir = (dir) => {
            //# Watch a directory for new/newly named files,
            //# which triggers re-evaluating glob to see if new files to watch.
            return watchers[dir] != null ? watchers[dir] : watchers[dir] = fsNormal.watch(dir, (eventType) => {
              return find(true); //if eventType == 'rename'
            }).on('error', (error) => {
              var ref;
              if ((ref = error.code) === 'ENOENT' || ref === 'EPERM') {
                console.log(`. ${dir} no longer exists`);
                return delete watchers[dir];
              } else {
                return this.emit('error', error);
              }
            });
          };
          find = (convert) => {
            //# Evaluate glob, watch all matching files for changes,
            //# and watch all prefix directories for new files as well,
            //# as they might affect the glob.
            //# Also convert newly matching files if specified.
            return this.makeGlob(input, {
              nodir: true
            }).on('match', (file) => {
              var ref, slash;
              if (convert && (watchers[file] == null)) {
                handle(file);
              }
              watchFile(file);
              ref = file.matchAll('/');
              for (slash of ref) {
                watchDir(file.slice(0, slash.index));
              }
              if (!file.startsWith('/')) {
                return watchDir('.');
              }
            });
          };
          return find();
        })(input);
      }
    }
    return void 0;
  }

};

help = function() {
  return console.log(`svgink ${metadata.version}
Usage: ${process.argv[1]} (...options and filenames/directories/globs...)
Documentation: https://github.com/edemaine/svgink

Filenames or glob patterns should specify SVG files.
Directories implicitly refer to *.svg within the directory.
Optional arguments:
  -h / --help           Show this help message and exit.
  -p / --pdf            Convert SVG files to PDF via Inkscape
  -P / --png            Convert SVG files to PNG via Inkscape
  -w / --watch          Continuously watch for changed files and convert them
  -f / --force          Force conversion even if output newer than SVG input
  -o DIR / --output DIR Write all output files to directory DIR
  --op DIR / --output-pdf DIR   Write all .pdf files to directory DIR
  --oP DIR / --output-png DIR   Write all .png files to directory DIR
  --clean               Delete PDF/PNG files that would be generated
  -i PATH / --inkscape PATH     Specify PATH to Inkscape binary
  --no-sanitize         Don't sanitize PDF output by blanking out /CreationDate
  --relative            Run jobs with relative paths (default uses absolute)
  -j N / --jobs N       Run up to N Inkscape jobs in parallel`);
};

main = async function(args = process.argv.slice(2)) {
  var arg, files, formats, i, input, inputs, j, len, processor, settings, skip, start, watch;
  start = new Date();
  settings = {...defaultSettings};
  files = {
    input: 0,
    output: 0,
    skip: 0
  };
  processor = new SVGProcessor(settings).on('input', () => {
    return files.input++;
  }).on('converted', (data) => {
    files.output++;
    if (data.skip) {
      files.skip++;
      return console.log(`- ${data.input} -> ${data.output} (skipped)`);
    } else {
      console.log(`* ${data.input} -> ${data.output}`);
      if (data.stdout) {
        console.log(data.stdout);
      }
      if (data.stderr) {
        return console.log(data.stderr);
      }
    }
  }).on('cleaned', (data) => {
    files.output++;
    if (data.skip) {
      files.skip++;
      return console.log(`- ${data.output} (already cleaned)`);
    } else {
      return console.log(`* ${data.output} CLEANED`);
    }
  }).on('error', (error) => {
    if (error.input != null) {
      console.log(`! ${error.input} -> ${error.output} FAILED`);
    } else {
      console.log("! Unknown error");
    }
    return console.log(error);
  });
  watch = false;
  formats = [];
  inputs = [];
  skip = 0;
  for (i = j = 0, len = args.length; j < len; i = ++j) {
    arg = args[i];
    if (skip) {
      skip--;
      continue;
    }
    switch (arg) {
      case '-h':
      case '--help':
        help();
        break;
      case '-w':
      case '--watch':
        watch = true;
        break;
      case '-f':
      case '--force':
        settings.force = true;
        break;
      case '-i':
      case '--inkscape':
        skip = 1;
        settings.inkscape = args[i + 1];
        break;
      case '-o':
      case '--output':
        skip = 1;
        settings.outputDir = args[i + 1];
        break;
      case '--op':
      case '--output-pdf':
        skip = 1;
        settings.outputDirExt['.pdf'] = args[i + 1];
        break;
      case '--oP':
      case '--output-png':
        skip = 1;
        settings.outputDirExt['.png'] = args[i + 1];
        break;
      case '--clean':
        settings.clean = true;
        break;
      case '-p':
      case '--pdf':
        formats.push('pdf');
        break;
      case '-P':
      case '--png':
        formats.push('png');
        break;
      case '--no-sanitize':
        settings.sanitize = false;
        break;
      case '--relative':
        settings.relative = true;
        break;
      case '-j':
      case '--jobs':
        skip = 1;
        arg = parseInt(args[i + 1]);
        if (arg) {
          settings.jobs = arg;
        } else {
          console.warn(`Invalid argument to --jobs: ${args[i + 1]}`);
        }
        break;
      default:
        inputs.push(input = arg);
        processor.convertGlob(input, formats);
    }
  }
  if (watch) {
    await processor.wait();
  } else {
    await processor.close();
  }
  if (!formats.length) {
    console.log('! Not enough formats. Specify --pdf and/or --png.');
    return help();
  } else if (!files) {
    console.log('! Not enough filename arguments');
    return help();
  } else {
    if (settings.clean) {
      console.log(`> Cleaned ${files.output - files.skip} out of ${files.output} files that would be generated by the ${files.input} SVG files in ${Math.round((new Date()) - start) / 1000} seconds`);
    } else {
      console.log(`> Converted ${files.input} SVG files into ${files.output} files (${files.output - files.skip} updated) in ${Math.round((new Date()) - start) / 1000} seconds`);
      if (files.skip) {
        console.log(`> Skipped ${files.skip} conversions.  To force conversion, use --force`);
      }
    }
    if (watch) {
      console.log('> Watching for changes... (Ctrl-C to exit)');
      return processor.watch(inputs, formats);
    }
  }
};

module.exports = {defaultSettings, InkscapeError, Inkscape, SVGProcessor, main};

if ((typeof module !== "undefined" && module !== null) && (typeof require !== "undefined" && require !== null ? require.main : void 0) === module) {
  main();
}

//setTimeout(log, 5000).unref()
